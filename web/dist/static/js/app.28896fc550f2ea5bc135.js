webpackJsonp([1],{"+Ul+":function(e,t,n){e.exports=n.p+"static/img/weichat.45b5571.png"},"2/Vp":function(e,t){},B50u:function(e,t){},DjBz:function(e,t){},FmQI:function(e,t){},H2B1:function(e,t){},JG8F:function(e,t,n){e.exports=n.p+"static/img/swagger2_2.51fa568.png"},NHnr:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var r=n("IvJb"),a={render:function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("div",{staticClass:"bottom"},[r("p",[e._v("PS：你的star是我学习的动力")]),e._v(" "),e._m(0),e._v(" "),r("p",[e._v("也可以选择以下两种方式支持我")]),e._v(" "),r("row",{staticClass:"row",attrs:{type:"flex",justify:"center",gutter:20}},[r("i-col",{attrs:{span:"3"}},[r("div",[r("img",{attrs:{src:n("+Ul+")}})]),e._v(" "),r("p",[e._v("微信支持")])]),e._v(" "),r("i-col",{attrs:{span:"3"}},[r("div",[r("img",{attrs:{src:n("Zx4y")}})]),e._v(" "),r("p",[e._v("支付宝支持")])])],1)],1)},staticRenderFns:[function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("github地址："),t("a",{attrs:{href:"https://github.com/codeyoyo/spring-boot-learn",target:"_bank"}},[this._v("\n    https://github.com/codeyoyo/spring-boot-learn")])])}]};var o=n("C7Lr")({},a,!1,function(e){n("uTyR")},"data-v-6d82dd20",null).exports,i=n("JJ4F"),s=n.n(i),p={name:"App",data:function(){return{routerList:[]}},components:{bottom:o},methods:{toLink:function(e){e&&this.$router.push(e)}},created:function(){this.routerList=this.$router.options.routes,console.log("routerList",this.routerList)},watch:{$route:{handler:function(e,t){this.$nextTick(function(){document.body.scrollTop=document.documentElement.scrollTop=0,document.querySelectorAll("pre code").forEach(function(e){s.a.highlightBlock(e)})})},deep:!0}}},c={render:function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{attrs:{id:"app"}},[n("div",{staticClass:"menu wrapper-header-nav"},[n("i-menu",{attrs:{mode:"horizontal",theme:"light","active-name":"1"},on:{"on-select":e.toLink}},e._l(e.routerList,function(t,r){return n("div",{key:r},[t.children?e._e():n("menu-item",{attrs:{name:t.path}},[n("Icon",{attrs:{type:"ios-paper"}}),e._v("\n              "+e._s(t.cnName)+"\n        ")],1),e._v(" "),t.children?n("submenu",{attrs:{name:t.name}},[n("template",{slot:"title"},[n("icon",{attrs:{type:"md-cog"}}),e._v("\n                "+e._s(t.cnName)+"\n            ")],1),e._v(" "),e._l(t.children,function(r,a){return n("menu-item",{key:a,attrs:{name:t.path+"/"+r.path}},[e._v(e._s(r.cnName))])})],2):e._e()],1)}))],1),e._v(" "),n("div",{staticStyle:{height:"61px"}}),e._v(" "),n("router-view"),e._v(" "),n("bottom"),e._v(" "),n("back-top")],1)},staticRenderFns:[]};var l=n("C7Lr")(p,c,!1,function(e){n("YUAb")},null,null).exports,v=n("KGCO"),_={render:function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("div",{staticClass:"start"},[r("h2",[e._v("项目搭建")]),e._v(" "),r("row",{staticClass:"code-row-bg row",attrs:{type:"flex",justify:"start"}},[r("i-col",{attrs:{span:"15"}},[r("p",{staticClass:"p-indent"},[e._v("第一种搭建方式：可访问"),r("a",{attrs:{href:"http://start.spring.io/",target:"_bank"}},[e._v("http://start.spring.io/")]),e._v(" \n            选择构建工具Maven Project、Spring Boot版本1.3.2以及一些工程基本信息，可参考下图所示：")]),e._v(" "),r("div",{staticClass:"img-box"},[r("img",{attrs:{src:n("mE74")}})])])],1),e._v(" "),r("row",{staticClass:"code-row-bg row",attrs:{type:"flex",justify:"end"}},[r("i-col",{attrs:{span:"15"}},[r("p",{staticClass:"p-indent"},[e._v("第二种搭建方式：可通过IDEA进行项目构建，可参考下图所示：")]),e._v(" "),r("div",{staticClass:"img-box"},[r("img",{attrs:{src:n("eD7Y")}})])])],1)],1)},staticRenderFns:[]};var d=n("C7Lr")({},_,!1,function(e){n("fONQ")},"data-v-2dba2df4",null).exports,u={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this.$createElement,t=this._self._c||e;return t("section",[t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[this._v("<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n")])])])}]},g={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this.$createElement,t=this._self._c||e;return t("section",[t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[this._v("<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n")])])])}]},m={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this.$createElement,t=this._self._c||e;return t("section",[t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[this._v('@RestController\npublic class HelloController {\n\n    @RequestMapping("/hello")\n    public String index() {\n        return "Hello World";\n    }\n    \n}\n')])])])}]},h={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this.$createElement,t=this._self._c||e;return t("section",[t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[this._v('@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class Lesson1ApplicationTests {\n\n\tprivate MockMvc mvc;\n\n\t@Before\n\tpublic void setUp(){\n\t\ttry{\n\t\t\tmvc=MockMvcBuilders.standaloneSetup(new HelloController()).build();\n\t\t}catch (Exception ex){\n\t\t\tex.printStackTrace();\n\t\t}\n\t}\n\n\t@Test\n\tpublic void contextLoads() {\n\t\ttry {\n\t\t\tmvc.perform(MockMvcRequestBuilders.get("/hello").accept(MediaType.APPLICATION_JSON)).andExpect(status().isOk()).andExpect(content().string(equalTo("Hello World")));\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n}\n')])])])}]},f={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this.$createElement,t=this._self._c||e;return t("section",[t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[this._v("import static org.hamcrest.Matchers.equalTo;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n")])])])}]},b={data:function(){return{}},components:{pom:n("C7Lr")(null,u,!1,null,null,null).exports,web:n("C7Lr")(null,g,!1,null,null,null).exports,helloCode:n("C7Lr")(null,m,!1,null,null,null).exports,test:n("C7Lr")(null,h,!1,null,null,null).exports,importDom:n("C7Lr")(null,f,!1,null,null,null).exports},mounted:function(){}},y={render:function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("div",{staticClass:"first"},[r("h2",[e._v("编写HelloWorld")]),e._v(" "),r("tabs",[r("tab-pane",{attrs:{label:"项目结构",icon:"md-code"}},[r("div",{staticClass:"tab-item"},[r("h3",[e._v("项目结构")]),e._v(" "),r("div",{staticClass:"img-box"},[r("img",{attrs:{src:n("v9vT")}})])])]),e._v(" "),r("tab-pane",{attrs:{label:"引入Web模块",icon:"md-code"}},[r("div",{staticClass:"tab-item"},[r("h3",[e._v("引入Web模块")]),e._v(" "),r("div",{staticClass:"context-box"},[r("p",[e._v("当前的"),r("span",{staticClass:"code"},[e._v("pom.xml")]),e._v("内容如下，仅引入了两个模块：")]),e._v(" "),r("ul",[r("li",[r("span",{staticClass:"code"},[e._v("spring-boot-starter")]),e._v("：核心模块，包括自动配置支持、日志和YAML\n                  ")]),e._v(" "),r("li",[r("span",{staticClass:"code"},[e._v("spring-boot-starter-test")]),e._v("：测试模块，包括JUnit、Hamcrest、Mockito\n                  ")])]),e._v(" "),r("pom",{directives:[{name:"highlight",rawName:"v-highlight"}]}),e._v(" "),r("p",[e._v("\n                    引入Web模块，需添加"),r("span",{staticClass:"code"},[e._v("spring-boot-starter-web")]),e._v("模块：\n                  ")]),e._v(" "),r("web",{directives:[{name:"highlight",rawName:"v-highlight"}]})],1)])]),e._v(" "),r("tab-pane",{attrs:{label:"编写HelloWorld服务",icon:"md-code"}},[r("div",{staticClass:"tab-item"},[r("h3",[e._v("编写HelloWorld服务")]),e._v(" "),r("div",{staticClass:"context-box"},[r("ul",[r("li",[e._v("\n                  创建\n                  "),r("span",{staticClass:"code"},[e._v("package")]),e._v("\n                  命名为\n                  "),r("span",{staticClass:"code"},[e._v("com.example.lesson1")]),e._v("\n                  （根据实际情况修改）\n                ")]),e._v(" "),r("li",[e._v("\n                  创建\n                  "),r("span",{staticClass:"code"},[e._v("HelloController")]),e._v("类，内容如下:\n                ")])]),e._v(" "),r("hello-code",{directives:[{name:"highlight",rawName:"v-highlight"}]}),e._v(" "),r("ul",[r("li",[e._v("\n                  启动主程序，打开浏览器访问\n                  "),r("span",{staticClass:"code"},[e._v("http://localhost:8080/hello")]),e._v("，可以看到页面输出\n                  "),r("span",{staticClass:"code"},[e._v("\n                    Hello World\n                  ")])])])],1)])]),e._v(" "),r("tab-pane",{attrs:{label:"编写单元测试用例",icon:"md-code"}},[r("div",{staticClass:"tab-item"},[r("h3",[e._v("编写单元测试用例")]),e._v(" "),r("div",{staticClass:"context-box"},[r("p",[e._v("\n                  打开的"),r("span",{staticClass:"code"},[e._v("src/test/")]),e._v("下的测试入口"),r("span",{staticClass:"code"},[e._v("Chapter1ApplicationTests")]),e._v("类。下面编写一个简单的单元测试来模拟http请求，具体如下：\n                ")]),e._v(" "),r("test",{directives:[{name:"highlight",rawName:"v-highlight"}]}),e._v(" "),r("p",[e._v("\n                  使用"),r("span",{staticClass:"code"},[e._v("MockServletContext")]),e._v("来构建一个空的"),r("span",{staticClass:"code"},[e._v("WebApplicationContext")]),e._v("，这样我们创建的"),r("span",{staticClass:"code"},[e._v("HelloController")]),e._v("就可以在"),r("span",{staticClass:"code"},[e._v("@Before")]),e._v("函数中创建并传递到"),r("span",{staticClass:"code"},[e._v("MockMvcBuilders.standaloneSetup（）")]),e._v("函数中。\n                ")]),e._v(" "),r("ul",[r("li",[e._v("\n                    注意引入下面内容，让"),r("span",{staticClass:"code"},[e._v("status")]),e._v("、\n                    "),r("span",{staticClass:"code"},[e._v("content")]),e._v("、"),r("span",[e._v("equalTo")]),e._v("函数可用\n                  ")])]),e._v(" "),r("import-dom",{directives:[{name:"highlight",rawName:"v-highlight"}]}),e._v(" "),r("p",[e._v("\n                  至此已完成目标，通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。\n                ")])],1)])])],1)],1)},staticRenderFns:[]};var S={name:"HelloWorld",data:function(){return{}},components:{Start:d,FirstApp:n("C7Lr")(b,y,!1,function(e){n("DjBz")},"data-v-01814d1f",null).exports},methods:{},created:function(){}},E={render:function(){var e=this.$createElement,t=this._self._c||e;return t("div",[this._m(0),this._v(" "),t("start"),this._v(" "),t("first-app")],1)},staticRenderFns:[function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"hello"},[t("div",{staticClass:"context"},[t("h1",{staticClass:"tada animated"},[this._v("Spring Boot"),t("span",[this._v("2.0")])]),this._v(" "),t("h2",[this._v("学习笔记")]),this._v(" "),t("p",[this._v("简介：我第一次接触到Spring Boot这个框架是在2017年11月，那时候公司对系统进行了重新架构，偶合之下接触以及学到Spring Boot 这个框架；因为某些原因离开了上家公司，来到新公司是做华为外包的，信息这方面比较封闭，我们PM希望我们能分享下外面的新知识，所以我就再重新学习Spring Boot做下这一系列的学习笔记与大家分享共勉。")])])])}]};var A=n("C7Lr")(S,E,!1,function(e){n("2/Vp")},"data-v-568a27a2",null).exports,R={render:function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"btns"},[n("row",{attrs:{type:"flex",justify:"center"}},[n("i-col",{attrs:{span:"12"}},[n("i-button",{attrs:{type:"primary"},on:{click:e.upClick}},[n("icon",{attrs:{type:"ios-arrow-back"}}),e._v(" "),n("router-link",{attrs:{to:{path:e.up}}},[e._v("上一篇")])],1)],1),e._v(" "),n("i-col",{attrs:{span:"12"}},[n("i-button",{attrs:{type:"primary"},on:{click:e.nextClick}},[n("router-link",{attrs:{to:{path:e.next}}},[e._v("下一篇")]),e._v(" "),n("icon",{attrs:{type:"ios-arrow-forward"}})],1)],1)],1)],1)},staticRenderFns:[]};var T={props:["title","date","up","next"],components:{contextBtn:n("C7Lr")({props:["up","next"],methods:{upClick:function(){this.up&&this.$router.push(this.up)},nextClick:function(){this.next&&this.$router.push(this.next)}}},R,!1,function(e){n("FmQI")},"data-v-f96254a8",null).exports}},x={render:function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"context-box"},[n("row",{attrs:{type:"flex",justify:"center"}},[n("i-col",{staticClass:"shadow",attrs:{span:"14"}},[n("h1",{domProps:{textContent:e._s(e.title)}}),e._v(" "),n("p",{staticClass:"article-meta"},[n("span",{staticClass:"label label-success"},[e._v("原创")]),e._v(" "),n("icon",{attrs:{type:"md-calendar",size:"20"}}),e._v(" "),n("span",{staticClass:"date",domProps:{textContent:e._s(e.date)}})],1),e._v(" "),n("div",{staticClass:"context"},[e._t("default")],2)])],1),e._v(" "),n("context-btn",{attrs:{up:e.up,next:e.next}})],1)},staticRenderFns:[]};var C=n("C7Lr")(T,x,!1,function(e){n("H2B1")},"data-v-a514f55c",null).exports,M=n("9r/T"),w=function(e,t,n){for(var r="",a=0;a<e.length;a++){var o=e[a];if(o.name==t[0]){var i=o.path,s="";if(o.children&&t.length>1){for(var p=0;p<o.children.length;p++){if(o.children[p].name==t[1])if(n){if(p-1>=0){s="/"+o.children[p-1].path;break}}else if(p+1<o.children.length){s="/"+o.children[p+1].path;break}}if(i&&s){r=i+s;break}if(n){if(a-1>0){i=(c=e[a-1]).path,c.children&&(s="/"+c.children[c.children.length-1].path),r=i+s;break}}else if(a+1<e.length){var c;i=(c=e[a+1]).path,c.children&&(s="/"+c.children[0].path),r=i+s;break}}}}return r||(r="/"),r},B={data:function(){return{title:"",date:"",up:"",next:"",currLocal:""}},components:{postMain:C},methods:{variateBulid:function(){var e=this.$router.options.routes,t=window.location.hash;this.currLocal=t;var n=t.replace("#/","").split("/"),r=function(e,t){var n=function(e){var t={title:"",date:"",up:"",next:""};return e.title&&(t.title=e.title),e.date&&(t.date=e.date),t};for(var r in t){var a=t[r];if(e[0]==a.name){if(!(a.children&&e.length>1))return n(a);for(var o in a.children){var i=a.children[o];if(i.name==e[1])return n(i)}}}return{}}(n,e);this.title=r.title,this.date=r.date,this.up=w(e,n,!0),this.next=w(e,n,!1)}},created:function(){var e=this;this.variateBulid(),Object(M.setInterval)(function(){window.location.hash!=e.currLocal&&e.variateBulid()},1e3)}},I={render:function(){var e=this.$createElement,t=this._self._c||e;return t("div",{directives:[{name:"highlight",rawName:"v-highlight"}]},[t("post-main",{attrs:{title:this.title,date:this.date,up:this.up,next:this.next}},[t("router-view")],1)],1)},staticRenderFns:[]};var L=n("C7Lr")(B,I,!1,function(e){n("B50u")},"data-v-7dae7529",null).exports,j={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("p",[e._v("相信很多人选择Spring Boot主要是考虑到它既能兼顾Spring的强大功能，还能实现快速开发的便捷。我们在Spring Boot使用过程中，最直观的感受就是没有了原来自己整合Spring应用时繁多的XML配置内容，替代它的是在"),n("code",{pre:!0},[e._v("pom.xml")]),e._v("中引入模块化的"),n("code",{pre:!0},[e._v("Starter POMs")]),e._v("，其中各个模块都有自己的默认配置，所以如果不是特殊应用场景，就只需要在"),n("code",{pre:!0},[e._v("application.properties")]),e._v("中完成一些属性配置就能开启各模块的应用。")]),e._v(" "),n("p",[e._v("在之前的各篇文章中都有提及关于"),n("code",{pre:!0},[e._v("application.properties")]),e._v("的使用，主要用来配置数据库连接、日志相关配置等。除了这些配置内容之外，本文将具体介绍一些在"),n("code",{pre:!0},[e._v("application.properties")]),e._v("配置中的其他特性和使用方法。")]),e._v(" "),n("h2",[e._v("自定义属性与加载")]),e._v(" "),n("p",[e._v("我们在使用Spring Boot的时候，通常也需要定义一些自己使用的属性，我们可以如下方式直接定义：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("com.lesson.name=Spring Boot笔记\ncom.lesson.title=Spring Boot属性配置文件详解\n")])]),e._v(" "),n("p",[e._v("然后通过"),n("code",{pre:!0},[e._v('@Value("${属性名}")')]),e._v("注解来加载对应的配置属性，具体如下：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@Component\npublic class BlogProperties {\n\n    @Value("${com.example.lesson.name}")\n    private String name;\n    @Value("${com.examplelesson.title}")\n    private String title;\n\n    // 省略getter和setter\n\n}\n')])]),e._v(" "),n("p",[e._v("按照惯例，通过单元测试来验证BlogProperties中的属性是否已经根据配置文件加载了。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('RunWith(SpringJUnit4ClassRunner.class)\n@SpringApplicationConfiguration(Application.class)\npublic class ApplicationTests {\n\n\t@Autowired\n\tprivate BlogProperties blogProperties;\n\n\n\t@Test\n\tpublic void getHello() throws Exception {\n\t\tAssert.assertEquals(blogProperties.getName(), "lesson");\n\t\tAssert.assertEquals(blogProperties.getTitle(), "Spring Boot笔记");\n\t}\n\n}\n')])]),e._v(" "),n("h2",[e._v("参数间的引用")]),e._v(" "),n("p",[e._v("在"),n("code",{pre:!0},[e._v("application.properties")]),e._v("中的各个参数之间也可以直接引用来使用，就像下面的设置：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("com.example.lesson.name=lesson\ncom.example.lesson.title=Spring Boot教程\ncom.example.lesson.desc=${com.example.lesson.name}正在努力写《${com.example.lesson.title}》\n")])]),e._v(" "),n("p",[n("code",{pre:!0},[e._v("com.example.lesson.desc")]),e._v("参数引用了上文中定义的"),n("code",{pre:!0},[e._v("name")]),e._v("和"),n("code",{pre:!0},[e._v("title")]),e._v("属性，最后该属性的值就是"),n("code",{pre:!0},[e._v("正在努力写《Spring Boot笔记》")]),e._v("。")]),e._v(" "),n("h2",[e._v("使用随机数")]),e._v(" "),n("p",[e._v("在一些情况下，有些参数我们需要希望它不是一个固定的值，比如密钥、服务端口等。Spring Boot的属性配置文件中可以通过"),n("code",{pre:!0},[e._v("${random}")]),e._v("来产生int值、long值或者string字符串，来支持属性的随机值。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("# 随机字符串\ncom.example.lesson.value=${random.value}\n# 随机int\ncom.example.lesson.number=${random.int}\n# 随机long\ncom.example.lesson.bignumber=${random.long}\n# 10以内的随机数\ncom.example.lesson.test1=${random.int(10)}\n# 10-20的随机数\ncom.example.lesson.test2=${random.int[10,20]}\n")])]),e._v(" "),n("h2",[e._v("通过命令行设置属性值")]),e._v(" "),n("p",[e._v("相信使用过一段时间Spring Boot的用户，一定知道这条命令："),n("code",{pre:!0},[e._v("java -jar xxx.jar --server.port=8888")]),e._v("，通过使用–server.port属性来设置xxx.jar应用的端口为8888。")]),e._v(" "),n("p",[e._v("在命令行运行时，连续的两个减号"),n("code",{pre:!0},[e._v("--")]),e._v("就是对"),n("code",{pre:!0},[e._v("application.properties")]),e._v("中的属性值进行赋值的标识。所以，"),n("code",{pre:!0},[e._v("java -jar xxx.jar --server.port=8888")]),e._v("命令，等价于我们在"),n("code",{pre:!0},[e._v("application.properties")]),e._v("中添加属性"),n("code",{pre:!0},[e._v("server.port=8888")]),e._v("，该设置在样例工程中可见，读者可通过删除该值或使用命令行来设置该值来验证。")]),e._v(" "),n("p",[e._v("通过命令行来修改属性值固然提供了不错的便利性，但是通过命令行就能更改应用运行的参数，那岂不是很不安全？是的，所以Spring Boot也贴心的提供了屏蔽命令行访问属性的设置，只需要这句设置就能屏蔽："),n("code",{pre:!0},[e._v("SpringApplication.setAddCommandLineProperties(false)")]),e._v("。")]),e._v(" "),n("h2",[e._v("多环境配置")]),e._v(" "),n("p",[e._v("我们在开发Spring Boot应用时，通常同一套程序会被应用和安装到几个不同的环境，比如：开发、测试、生产等。其中每个环境的数据库地址、服务器端口等等配置都会不同，如果在为不同环境打包时都要频繁修改配置文件的话，那必将是个非常繁琐且容易发生错误的事。")]),e._v(" "),n("p",[e._v("对于多环境的配置，各种项目构建工具或是框架的基本思路是一致的，通过配置多份不同环境的配置文件，再通过打包命令指定需要打包的内容之后进行区分打包，Spring Boot也不例外，或者说更加简单。")]),e._v(" "),n("p",[e._v("在Spring Boot中多环境配置文件名需要满足"),n("code",{pre:!0},[e._v("application-{profile}.properties")]),e._v("的格式，其中"),n("code",{pre:!0},[e._v("{profile}")]),e._v("对应你的环境标识，比如：")]),e._v(" "),n("ul",[n("li",[n("code",{pre:!0},[e._v("application-dev.properties")]),e._v("：开发环境")]),e._v(" "),n("li",[n("code",{pre:!0},[e._v("application-test.properties")]),e._v("：测试环境")]),e._v(" "),n("li",[n("code",{pre:!0},[e._v("application-prod.properties")]),e._v("：生产环境")])]),e._v(" "),n("p",[e._v("至于哪个具体的配置文件会被加载，需要在"),n("code",{pre:!0},[e._v("application.properties")]),e._v("文件中通过"),n("code",{pre:!0},[e._v("spring.profiles.active")]),e._v("属性来设置，其值对应"),n("code",{pre:!0},[e._v("{profile}")]),e._v("值。")]),e._v(" "),n("p",[e._v("如："),n("code",{pre:!0},[e._v("spring.profiles.active=test")]),e._v("就会加载"),n("code",{pre:!0},[e._v("application-test.properties")]),e._v("配置文件内容")]),e._v(" "),n("p",[e._v("下面，以不同环境配置不同的服务端口为例，进行样例实验。")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("针对各环境新建不同的配置文件"),n("code",{pre:!0},[e._v("application-dev.properties")]),e._v("、"),n("code",{pre:!0},[e._v("application-test.properties")]),e._v("、"),n("code",{pre:!0},[e._v("application-prod.properties")])])]),e._v(" "),n("li",[n("p",[e._v("在这三个文件均都设置不同的"),n("code",{pre:!0},[e._v("server.port")]),e._v("属性，如：dev环境设置为1111，test环境设置为2222，prod环境设置为3333")])]),e._v(" "),n("li",[n("p",[e._v("application.properties中设置"),n("code",{pre:!0},[e._v("spring.profiles.active=dev")]),e._v("，就是说默认以dev环境设置")])]),e._v(" "),n("li",[n("p",[e._v("测试不同配置的加载")]),e._v(" "),n("ul",[n("li",[e._v("执行"),n("code",{pre:!0},[e._v("java -jar xxx.jar")]),e._v("，可以观察到服务端口被设置为"),n("code",{pre:!0},[e._v("1111")]),e._v("，也就是默认的开发环境（dev）")]),e._v(" "),n("li",[e._v("执行"),n("code",{pre:!0},[e._v("java -jar xxx.jar --spring.profiles.active=test")]),e._v("，可以观察到服务端口被设置为"),n("code",{pre:!0},[e._v("2222")]),e._v("，也就是测试环境的配置（test）")]),e._v(" "),n("li",[e._v("执行"),n("code",{pre:!0},[e._v("java -jar xxx.jar --spring.profiles.active=prod")]),e._v("，可以观察到服务端口被设置为"),n("code",{pre:!0},[e._v("3333")]),e._v("，也就是生产环境的配置（prod）")])])])]),e._v(" "),n("p",[e._v("按照上面的实验，可以如下总结多环境的配置思路：")]),e._v(" "),n("ul",[n("li",[n("code",{pre:!0},[e._v("application.properties")]),e._v("中配置通用内容，并设置"),n("code",{pre:!0},[e._v("spring.profiles.active=dev")]),e._v("，以开发环境为默认配置")]),e._v(" "),n("li",[n("code",{pre:!0},[e._v("application-{profile}.properties")]),e._v("中配置各个环境不同的内容")]),e._v(" "),n("li",[e._v("通过命令行方式去激活不同环境的配置")])]),e._v(" "),n("p",[n("a",{attrs:{href:"http://git.oschina.net/didispace/SpringBoot-Learning"}},[e._v("完整示例chapter2-1-1")])])])}]},P={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("p",[e._v("在Spring Boot 2.0中推出了Relaxed Binding 2.0，对原有的属性绑定功能做了非常多的改进以帮助我们更容易的在Spring应用中加载和读取配置信息。下面本文就来说说Spring Boot 2.0中对配置的改进。")]),e._v(" "),n("h2",[e._v("配置文件绑定")]),e._v(" "),n("h3",[e._v("简单类型")]),e._v(" "),n("p",[e._v("在Spring Boot 2.0中对配置属性加载的时候会除了像1.x版本时候那样移除特殊字符外，还会将配置均以全小写的方式进行匹配和加载。所以，下面的4种配置方式都是等价的：")]),e._v(" "),n("ul",[n("li",[e._v("properties格式：")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("spring.jpa.databaseplatform=mysql\nspring.jpa.database-platform=mysql\nspring.jpa.databasePlatform=mysql\nspring.JPA.database_platform=mysql\n")])]),e._v(" "),n("ul",[n("li",[e._v("yaml格式：")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("spring:\n  jpa:\n    databaseplatform: mysql\n    database-platform: mysql\n    databasePlatform: mysql\n    database_platform: mysql\n")])]),e._v(" "),n("p",[n("strong",[e._v("Tips：推荐使用全小写配合")]),n("code",{pre:!0},[e._v("-")]),n("strong",[e._v("分隔符的方式来配置，比如：")]),n("code",{pre:!0},[e._v("spring.jpa.database-platform=mysql")])]),e._v(" "),n("h3",[e._v("List类型")]),e._v(" "),n("p",[e._v("在properties文件中使用"),n("code",{pre:!0},[e._v("[]")]),e._v("来定位列表类型，比如：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("spring.my-example.url[0]=http://example.com\nspring.my-example.url[1]=http://spring.io\n")])]),e._v(" "),n("p",[e._v("也支持使用"),n("strong",[e._v("逗号")]),e._v("分割的配置方式，上面与下面的配置是等价的：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("spring.my-example.url=http://example.com,http://spring.io\n")])]),e._v(" "),n("p",[e._v("而在yaml文件中使用可以使用如下配置：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("spring:\n  my-example:\n    url:\n      - http://example.com\n      - http://spring.io\n")])]),e._v(" "),n("p",[e._v("也支持"),n("strong",[e._v("逗号")]),e._v("分割的方式：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("spring:\n  my-example:\n    url: http://example.com, http://spring.io\n")])]),e._v(" "),n("p",[n("strong",[e._v("注意：在Spring Boot 2.0中对于List类型的配置必须是连续的，不然会抛出")]),n("code",{pre:!0},[e._v("UnboundConfigurationPropertiesException")]),n("strong",[e._v("异常，所以如下配置是不允许的：")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("foo[0]=a\nfoo[2]=b\n")])]),e._v(" "),n("p",[e._v("***在Spring Boot 1.x中上述配置是可以的，"),n("code",{pre:!0},[e._v("foo[1]")]),n("strong",[e._v("由于没有配置，它的值会是")]),n("code",{pre:!0},[e._v("null")])]),e._v(" "),n("h3",[e._v("Map类型")]),e._v(" "),n("p",[e._v("Map类型在properties和yaml中的标准配置方式如下：")]),e._v(" "),n("ul",[n("li",[e._v("properties格式：")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("spring.my-example.foo=bar\nspring.my-example.hello=world\n")])]),e._v(" "),n("ul",[n("li",[e._v("yaml格式：")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("spring:\n  my-example:\n    foo: bar\n    hello: world\n")])]),e._v(" "),n("p",[n("strong",[e._v("注意：如果Map类型的key包含非字母数字和"),n("code",{pre:!0},[e._v("-")]),e._v("的字符，需要用"),n("code",{pre:!0},[e._v("[]")]),e._v("括起来，比如：")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("spring:\n  my-example:\n    '[foo.baz]': bar\n")])]),e._v(" "),n("h2",[e._v("环境属性绑定")]),e._v(" "),n("p",[n("strong",[e._v("简单类型")])]),e._v(" "),n("p",[e._v("在环境变量中通过小写转换与.替换"),n("code",{pre:!0},[e._v("_")]),e._v("来映射配置文件中的内容，比如：环境变量"),n("code",{pre:!0},[e._v("SPRING_JPA_DATABASEPLATFORM=mysql")]),e._v("的配置会产生与在配置文件中设置"),n("code",{pre:!0},[e._v("spring.jpa.databaseplatform=mysql")]),e._v("一样的效果。")]),e._v(" "),n("p",[n("strong",[e._v("List类型")])]),e._v(" "),n("p",[e._v("由于环境变量中无法使用"),n("code",{pre:!0},[e._v("[")]),e._v("和"),n("code",{pre:!0},[e._v("]")]),e._v("符号，所以使用_来替代。任何由下划线包围的数字都会被认为是"),n("code",{pre:!0},[e._v("[]")]),e._v("的数组形式。比如：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("MY_FOO_1_ = my.foo[1]\nMY_FOO_1_BAR = my.foo[1].bar\nMY_FOO_1_2_ = my.foo[1][2]\n")])]),e._v(" "),n("p",[e._v("另外，最后环境变量最后是以数字和下划线结尾的话，最后的下划线可以省略，比如上面例子中的第一条和第三条等价于下面的配置：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("MY_FOO_1 = my.foo[1]\nMY_FOO_1_2 = my.foo[1][2]\n")])]),e._v(" "),n("h2",[e._v("系统属性绑定")]),e._v(" "),n("p",[n("strong",[e._v("简单类型")])]),e._v(" "),n("p",[e._v("系统属性与文件配置中的类似，都以移除特殊字符并转化小写后实现绑定，比如下面的命令行参数都会实现配置"),n("code",{pre:!0},[e._v("spring.jpa.databaseplatform=mysql")]),e._v("的效果：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("-Dspring.jpa.database-platform=mysql\n-Dspring.jpa.databasePlatform=mysql\n-Dspring.JPA.database_platform=mysql\n")])]),e._v(" "),n("p",[n("strong",[e._v("List类型")])]),e._v(" "),n("p",[e._v("系统属性的绑定也与文件属性的绑定类似，通过"),n("code",{pre:!0},[e._v("[]")]),e._v("来标示，比如：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('-D"spring.my-example.url[0]=http://example.com"\n-D"spring.my-example.url[1]=http://spring.io"\n')])]),e._v(" "),n("p",[e._v("同样的，他也支持逗号分割的方式，比如：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("-Dspring.my-example.url=http://example.com,http://spring.io\n")])]),e._v(" "),n("h2",[e._v("属性的读取")]),e._v(" "),n("p",[e._v("上文介绍了Spring Boot 2.0中对属性绑定的内容，可以看到对于一个属性我们可以有多种不同的表达，但是如果我们要在Spring应用程序的environment中读取属性的时候，每个属性的唯一名称符合如下规则：")]),e._v(" "),n("ul",[n("li",[e._v("通过"),n("code",{pre:!0},[e._v(".")]),e._v("分离各个元素")]),e._v(" "),n("li",[e._v("最后一个"),n("code",{pre:!0},[e._v(".")]),e._v("将前缀与属性名称分开")]),e._v(" "),n("li",[e._v("必须是字母（a-z）和数字(0-9)")]),e._v(" "),n("li",[e._v("必须是小写字母")]),e._v(" "),n("li",[e._v("用连字符"),n("code",{pre:!0},[e._v("-")]),e._v("来分隔单词")]),e._v(" "),n("li",[e._v("唯一允许的其他字符是"),n("code",{pre:!0},[e._v("[")]),e._v("和"),n("code",{pre:!0},[e._v("]")]),e._v("，用于List的索引")]),e._v(" "),n("li",[e._v("不能以数字开头\n所以，如果我们要读取配置文件中"),n("code",{pre:!0},[e._v("spring.jpa.database-platform")]),e._v("的配置，可以这样写：")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('this.environment.containsProperty("spring.jpa.database-platform")\n')])]),e._v(" "),n("p",[e._v("而下面的方式是无法获取到"),n("code",{pre:!0},[e._v("spring.jpa.database-platform")]),e._v("配置内容的：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('this.environment.containsProperty("spring.jpa.databasePlatform")\n')])]),e._v(" "),n("p",[n("strong",[e._v("注意：使用"),n("code",{pre:!0},[e._v("@Value")]),e._v("获取配置内容的时候也需要这样的特点")])]),e._v(" "),n("h2",[e._v("全新的绑定API")]),e._v(" "),n("p",[e._v("在Spring Boot 2.0中增加了新的绑定API来帮助我们更容易的获取配置信息。下面举个例子来帮助大家更容易的理解：")]),e._v(" "),n("h3",[e._v("例子一：简单类型")]),e._v(" "),n("p",[e._v("假设在propertes配置中有这样一个配置："),n("code",{pre:!0},[e._v("com.didispace.foo=bar")]),e._v("\n我们为它创建对应的配置类：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@Data\n@ConfigurationProperties(prefix = "com.didispace")\npublic class FooProperties {\n\n    private String foo;\n\n}\n')])]),e._v(" "),n("p",[e._v("接下来，通过最新的"),n("code",{pre:!0},[e._v("Binder")]),e._v("就可以这样来拿配置信息了：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@SpringBootApplication\npublic class Application {\n\n    public static void main(String[] args) {\n        ApplicationContext context = SpringApplication.run(Application.class, args);\n\n        Binder binder = Binder.get(context.getEnvironment());\n\n        // 绑定简单配置\n        FooProperties foo = binder.bind("com.didispace", Bindable.of(FooProperties.class)).get();\n        System.out.println(foo.getFoo());\n    }\n}\n')])]),e._v(" "),n("h3",[e._v("例子二：List类型")]),e._v(" "),n("p",[e._v("如果配置内容是List类型呢？比如：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("com.didispace.post[0]=Why Spring Boot\ncom.didispace.post[1]=Why Spring Cloud\n\ncom.didispace.posts[0].title=Why Spring Boot\ncom.didispace.posts[0].content=It is perfect!\ncom.didispace.posts[1].title=Why Spring Cloud\ncom.didispace.posts[1].content=It is perfect too!\n")])]),e._v(" "),n("p",[e._v("要获取这些配置依然很简单，可以这样实现：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('ApplicationContext context = SpringApplication.run(Application.class, args);\n\nBinder binder = Binder.get(context.getEnvironment());\n\n// 绑定List配置\nList<String> post = binder.bind("com.didispace.post", Bindable.listOf(String.class)).get();\nSystem.out.println(post);\n\nList<PostInfo> posts = binder.bind("com.didispace.posts", Bindable.listOf(PostInfo.class)).get();\nSystem.out.println(posts);\n')])]),e._v(" "),n("h2",[e._v("代码示例")]),e._v(" "),n("p",[e._v("本文的相关例子可以查看下面仓库中的"),n("code",{pre:!0},[e._v("Chapter2-2-1")]),e._v("目录：")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/dyc87112/SpringBoot-Learning"}},[e._v("Github：https://github.com/dyc87112/SpringBoot-Learning")])])])}]},U={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("blockquote",[n("p",[n("strong",[e._v("今天继续来聊Spring Boot 2.0的新特性。本文将具体说说2.0版本中的事件模型，尤其是新增的事件：")]),n("code",{pre:!0},[e._v("ApplicationStartedEvent")]),e._v("。")])]),e._v(" "),n("p",[e._v("在Spring Boot 2.0中对事件模型做了一些增强，主要就是增加了"),n("code",{pre:!0},[e._v("ApplicationStartedEvent")]),e._v("事件，所以在2.0版本中所有的事件按执行的先后顺序如下：")]),e._v(" "),n("ul",[n("li",[n("code",{pre:!0},[e._v("ApplicationStartingEvent")])]),e._v(" "),n("li",[n("code",{pre:!0},[e._v("ApplicationEnvironmentPreparedEvent")])]),e._v(" "),n("li",[n("code",{pre:!0},[e._v("ApplicationPreparedEvent")])]),e._v(" "),n("li",[n("code",{pre:!0},[e._v("ApplicationStartedEvent")]),e._v(" <= 新增的事件")]),e._v(" "),n("li",[n("code",{pre:!0},[e._v("ApplicationReadyEvent")])]),e._v(" "),n("li",[n("code",{pre:!0},[e._v("ApplicationFailedEvent")])])]),e._v(" "),n("p",[e._v("从上面的列表中，我们可以看到"),n("code",{pre:!0},[e._v("ApplicationStartedEvent")]),e._v("位于"),n("code",{pre:!0},[e._v("ApplicationPreparedEvent")]),e._v("之后，"),n("code",{pre:!0},[e._v("ApplicationReadyEvent")]),e._v("之前。")]),e._v(" "),n("p",[e._v("下面我们通过代码的方式来直观的感受这个事件的切入位置，以便与将来我们在这个切入点加入自己需要的逻辑。")]),e._v(" "),n("p",[e._v("第一步：我们可以编写"),n("code",{pre:!0},[e._v("ApplicationPreparedEvent")]),e._v("、"),n("code",{pre:!0},[e._v("ApplicationStartedEvent")]),e._v("以及"),n("code",{pre:!0},[e._v("ApplicationReadyEvent")]),e._v("三个事件的监听器，然后在这三个事件触发的时候打印一些日志来观察它们各自的切入点，比如：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@Slf4j\npublic class ApplicationPreparedEventListener implements ApplicationListener<ApplicationPreparedEvent> {\n\n    @Override\n    public void onApplicationEvent(ApplicationPreparedEvent event) {\n        log.info("......ApplicationPreparedEvent......");\n    }\n\n}\n\n@Slf4j\npublic class ApplicationStartedEventListener implements ApplicationListener<ApplicationStartedEvent> {\n\n    @Override\n    public void onApplicationEvent(ApplicationStartedEvent event) {\n        log.info("......ApplicationStartedEvent......");\n    }\n\n}\n\n@Slf4j\npublic class ApplicationReadyEventListener implements ApplicationListener<ApplicationReadyEvent> {\n\n    @Override\n    public void onApplicationEvent(ApplicationReadyEvent event) {\n        log.info("......ApplicationReadyEvent......");\n    }\n\n}\n')])]),e._v(" "),n("p",[e._v("第二步：在"),n("code",{pre:!0},[e._v("/src/main/resources/")]),e._v("目录下新建："),n("code",{pre:!0},[e._v("META-INF/spring.factories")]),e._v("配置文件，通过配置"),n("code",{pre:!0},[e._v("org.springframework.context.ApplicationListener")]),e._v("来加载上面我们编写的监听器。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("org.springframework.context.ApplicationListener=\n  com.didispace.ApplicationPreparedEventListener,\\\n  com.didispace.ApplicationReadyEventListener,\\\n  com.didispace.ApplicationStartedEventListener\n")])]),e._v(" "),n("p",[e._v("此时，我们运行Spring Boot应用可以获得类似如下日志输出：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("2018-03-07 18:15:18.591  INFO 83387 --- [           main] com.didispace.Application                : Starting Application on zhaiyongchaodeMacBook-Pro.local with PID 83387 (/Users/zhaiyongchao/Documents/git/github/SpringBoot-Learning/Chapter1-2-1/target/classes started by zhaiyongchao in /Users/zhaiyongchao/Documents/git/github/SpringBoot-Learning/Chapter1-2-1)\n2018-03-07 18:15:18.591  INFO 83387 --- [           main] com.didispace.Application                : No active profile set, falling back to default profiles: default\n2018-03-07 18:15:18.658  INFO 83387 --- [           main] c.d.ApplicationPreparedEventListener     : ......ApplicationPreparedEvent......\n2018-03-07 18:15:18.662  INFO 83387 --- [           main] ConfigServletWebServerApplicationContext : Refreshing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@20d3d15a: startup date [Wed Mar 07 18:15:18 CST 2018]; root of context hierarchy\n2018-03-07 18:15:19.879  INFO 83387 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)\n2018-03-07 18:15:19.926  INFO 83387 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]\n2018-03-07 18:15:19.930  INFO 83387 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/8.5.28\n2018-03-07 18:15:19.946  INFO 83387 --- [ost-startStop-1] o.a.catalina.core.AprLifecycleListener   : The APR based Apache Tomcat Native library which allows optimal performance in production environments was not found on the java.library.path: [/Users/zhaiyongchao/Library/Java/Extensions:/Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java:.]\n2018-03-07 18:15:20.068  INFO 83387 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext\n2018-03-07 18:15:20.068  INFO 83387 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1410 ms\n2018-03-07 18:15:20.210  INFO 83387 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean  : Servlet dispatcherServlet mapped to [/]\n2018-03-07 18:15:20.214  INFO 83387 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'characterEncodingFilter' to: [/*]\n2018-03-07 18:15:20.214  INFO 83387 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]\n2018-03-07 18:15:20.214  INFO 83387 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'httpPutFormContentFilter' to: [/*]\n2018-03-07 18:15:20.215  INFO 83387 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: 'requestContextFilter' to: [/*]\n2018-03-07 18:15:20.513  INFO 83387 --- [           main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@20d3d15a: startup date [Wed Mar 07 18:15:18 CST 2018]; root of context hierarchy\n2018-03-07 18:15:20.592  INFO 83387 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/error]}\" onto public org.springframework.http.ResponseEntity<java.util.Map<java.lang.String, java.lang.Object>> org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController.error(javax.servlet.http.HttpServletRequest)\n2018-03-07 18:15:20.593  INFO 83387 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/error],produces=[text/html]}\" onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)\n2018-03-07 18:15:20.623  INFO 83387 --- [           main] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]\n2018-03-07 18:15:20.623  INFO 83387 --- [           main] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]\n2018-03-07 18:15:20.660  INFO 83387 --- [           main] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]\n2018-03-07 18:15:20.787  INFO 83387 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup\n2018-03-07 18:15:20.839  INFO 83387 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''\n2018-03-07 18:15:20.843  INFO 83387 --- [           main] com.didispace.Application                : Started Application in 2.866 seconds (JVM running for 3.337)\n2018-03-07 18:15:20.845  INFO 83387 --- [           main] c.d.ApplicationStartedEventListener      : ......ApplicationStartedEvent......\n2018-03-07 18:15:20.847  INFO 83387 --- [           main] c.d.ApplicationReadyEventListener        : ......ApplicationReadyEvent......\n")])]),e._v(" "),n("p",[e._v("从日志中我们可以看到清晰的看到"),n("code",{pre:!0},[e._v("ApplicationPreparedEvent")]),e._v("、"),n("code",{pre:!0},[e._v("ApplicationStartedEvent")]),e._v("以及"),n("code",{pre:!0},[e._v("ApplicationReadyEvent")]),e._v("三个事件的切入点。通过这个例子可能读者会感到疑问："),n("code",{pre:!0},[e._v("ApplicationStartedEvent")]),e._v("和"),n("code",{pre:!0},[e._v("ApplicationReadyEvent")]),e._v("从事件命名和日志输出位置来看，都是应用加载完成之后的事件，它们是否有什么区别呢？")]),e._v(" "),n("p",[e._v("下面可以看看官方文档对"),n("code",{pre:!0},[e._v("ApplicationStartedEvent")]),e._v("和"),n("code",{pre:!0},[e._v("ApplicationReadyEvent")]),e._v("的解释：")]),e._v(" "),n("blockquote",[n("p",[e._v("An ApplicationStartedEvent is sent after the context has been refreshed but before any application and command-line runners have been called.An ApplicationReadyEvent is sent after any application and command-line runners have been called. It indicates that the application is ready to service requests")])]),e._v(" "),n("p",[e._v("从文档中我们可以知道他们两中间还有一个过程就是"),n("code",{pre:!0},[e._v("command-line runners")]),e._v("被调用的内容。所以，为了更准确的感受这两个事件的区别，我们在应用主类中加入"),n("code",{pre:!0},[e._v("CommandLineRunner")]),e._v("的实现，比如：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@Slf4j\n@SpringBootApplication\npublic class Application {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n\n    @Bean\n    public DataLoader dataLoader() {\n        return new DataLoader();\n    }\n\n    @Slf4j\n    static class DataLoader implements CommandLineRunner {\n\n        @Override\n        public void run(String... strings) throws Exception {\n            log.info("Loading data...");\n        }\n    }\n\n}\n')])]),e._v(" "),n("p",[e._v("最后，我们再运行程序，此时我们可以发现这两个事件中间输出了上面定义的DataLoader的输出内容，具体如下：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("2018-03-07 18:15:20.845  INFO 83387 --- [main] c.d.ApplicationStartedEventListener      : ......ApplicationStartedEvent......\n2018-03-07 18:15:20.846  INFO 83387 --- [main] com.didispace.Application$DataLoader     : Loading data...\n2018-03-07 18:15:20.847  INFO 83387 --- [main] c.d.ApplicationReadyEventListener        : ......ApplicationReadyEvent......\n")])]),e._v(" "),n("h2",[e._v("代码示例")]),e._v(" "),n("p",[e._v("本文的相关例子可以查看下面仓库中的"),n("code",{pre:!0},[e._v("Chapter1-2-1")]),e._v("目录：")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"Github%EF%BC%9Ahttps://github.com/dyc87112/SpringBoot-Learning"}},[e._v("Github：https://github.com/dyc87112/SpringBoot-Learning")])])])])}]},k={path:"/config",cnName:"工程配置",component:L,name:"config",children:[{path:"ConfigIntroduce",component:n("C7Lr")(null,j,!1,null,null,null).exports,cnName:"配置文件详解",title:"Spring Boot属性配置文件详解",date:"2018-11-04",name:"ConfigIntroduce"},{path:"NewFeature1",component:n("C7Lr")(null,P,!1,null,null,null).exports,cnName:"2.0 新特性（一）",title:"Spring Boot 2.0 新特性（一）：配置绑定 2.0 全解析",date:"2018-11-05",name:"NewFeature1"},{path:"NewFeature2",component:n("C7Lr")(null,U,!1,null,null,null).exports,cnName:"2.0 新特性（二）",title:"Spring Boot 2.0 新特性（二）：新增事件ApplicationStartedEvent",date:"2018-11-06",name:"NewFeature2"}]},D={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("p",[e._v("之前介绍了很多Web层的例子，包括构建"),n("a",{attrs:{href:"/Web/RESTfulAPI"}},[e._v("RESTful API")]),e._v("、"),n("a",{attrs:{href:"/Web/Thymeleaf"}},[e._v("使用Thymeleaf模板引擎渲染Web视图")]),e._v("，但是这些内容还不足以构建一个动态的应用。通常我们做App也好，做Web应用也好，都需要内容，而内容通常存储于各种类型的数据库，服务端在接收到访问请求之后需要访问数据库获取并处理成展现给用户使用的数据形式。")]),e._v(" "),n("p",[e._v("本文介绍在Spring Boot基础下配置数据源和通过JdbcTemplate编写数据访问的示例。")]),e._v(" "),n("h2",[e._v("数据源配置")]),e._v(" "),n("p",[e._v("在我们访问数据库的时候，需要先配置一个数据源，下面分别介绍一下几种不同的数据库配置方式。")]),e._v(" "),n("p",[e._v("首先，为了连接数据库需要引入jdbc支持，在"),n("code",{pre:!0},[e._v("pom.xml")]),e._v("中引入如下配置：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-jdbc</artifactId>\n</dependency>\n")])]),e._v(" "),n("h3",[e._v("嵌入式数据库支持")]),e._v(" "),n("p",[e._v("嵌入式数据库通常用于开发和测试环境，不推荐用于生产环境。Spring Boot提供自动配置的嵌入式数据库有H2、HSQL、Derby，你不需要提供任何连接配置就能使用。")]),e._v(" "),n("p",[e._v("比如，我们可以在"),n("code",{pre:!0},[e._v("pom.xml")]),e._v("中引入如下配置使用HSQL")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("<dependency>\n    <groupId>org.hsqldb</groupId>\n    <artifactId>hsqldb</artifactId>\n    <scope>runtime</scope>\n</dependency>\n")])]),e._v(" "),n("h3",[e._v("连接生产数据源")]),e._v(" "),n("p",[e._v("以MySQL数据库为例，先引入MySQL连接的依赖包，在"),n("code",{pre:!0},[e._v("pom.xml")]),e._v("中加入：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n    <version>5.1.21</version>\n</dependency>\n")])]),e._v(" "),n("p",[e._v("在"),n("code",{pre:!0},[e._v("src/main/resources/application.properties")]),e._v("中配置数据源信息")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("spring.datasource.url=jdbc:mysql://localhost:3306/test\nspring.datasource.username=dbuser\nspring.datasource.password=dbpass\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\n")])]),e._v(" "),n("h3",[e._v("连接JNDI数据源")]),e._v(" "),n("p",[e._v("当你将应用部署于应用服务器上的时候想让数据源由应用服务器管理，那么可以使用如下配置方式引入JNDI数据源。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("spring.datasource.jndi-name=java:jboss/datasources/customers\n")])]),e._v(" "),n("h2",[e._v("使用JdbcTemplate操作数据库")]),e._v(" "),n("p",[e._v("Spring的JdbcTemplate是自动配置的，你可以直接使用"),n("code",{pre:!0},[e._v("@Autowired")]),e._v("来注入到你自己的bean中来使用。")]),e._v(" "),n("p",[e._v("举例：我们在创建"),n("code",{pre:!0},[e._v("User")]),e._v("表，包含属性"),n("code",{pre:!0},[e._v("name")]),e._v("、"),n("code",{pre:!0},[e._v("age")]),e._v("，下面来编写数据访问对象和单元测试用例。")]),e._v(" "),n("ul",[n("li",[e._v("定义包含有插入、删除、查询的抽象接口UserService")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("public interface UserService {\n\n    /**\n     * 新增一个用户\n     * @param name\n     * @param age\n     */\n    void create(String name, Integer age);\n\n    /**\n     * 根据name删除一个用户高\n     * @param name\n     */\n    void deleteByName(String name);\n\n    /**\n     * 获取用户总量\n     */\n    Integer getAllUsers();\n\n    /**\n     * 删除所有用户\n     */\n    void deleteAllUsers();\n\n}\n")])]),e._v(" "),n("ul",[n("li",[e._v("通过JdbcTemplate实现UserService中定义的数据访问操作")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@Service\npublic class UserServiceImpl implements UserService {\n\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n\n    @Override\n    public void create(String name, Integer age) {\n        jdbcTemplate.update("insert into USER(NAME, AGE) values(?, ?)", name, age);\n    }\n\n    @Override\n    public void deleteByName(String name) {\n        jdbcTemplate.update("delete from USER where NAME = ?", name);\n    }\n\n    @Override\n    public Integer getAllUsers() {\n        return jdbcTemplate.queryForObject("select count(1) from USER", Integer.class);\n    }\n\n    @Override\n    public void deleteAllUsers() {\n        jdbcTemplate.update("delete from USER");\n    }\n}\n')])]),e._v(" "),n("ul",[n("li",[e._v("创建对UserService的单元测试用例，通过创建、删除和查询来验证数据库操作的正确性。")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@RunWith(SpringJUnit4ClassRunner.class)\n@SpringApplicationConfiguration(Application.class)\npublic class ApplicationTests {\n\n\t@Autowired\n\tprivate UserService userSerivce;\n\n\t@Before\n\tpublic void setUp() {\n\t\t// 准备，清空user表\n\t\tuserSerivce.deleteAllUsers();\n\t}\n\n\t@Test\n\tpublic void test() throws Exception {\n\t\t// 插入5个用户\n\t\tuserSerivce.create("a", 1);\n\t\tuserSerivce.create("b", 2);\n\t\tuserSerivce.create("c", 3);\n\t\tuserSerivce.create("d", 4);\n\t\tuserSerivce.create("e", 5);\n\n\t\t// 查数据库，应该有5个用户\n\t\tAssert.assertEquals(5, userSerivce.getAllUsers().intValue());\n\n\t\t// 删除两个用户\n\t\tuserSerivce.deleteByName("a");\n\t\tuserSerivce.deleteByName("e");\n\n\t\t// 查数据库，应该有5个用户\n\t\tAssert.assertEquals(3, userSerivce.getAllUsers().intValue());\n\n\t}\n\n}\n')])]),e._v(" "),n("p",[e._v("上面介绍的"),n("code",{pre:!0},[e._v("JdbcTemplate")]),e._v("只是最基本的几个操作，更多其他数据访问操作的使用请参考："),n("a",{attrs:{href:"https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html"}},[e._v("JdbcTemplate API")])]),e._v(" "),n("p",[e._v("通过上面这个简单的例子，我们可以看到在Spring Boot下访问数据库的配置依然秉承了框架的初衷：简单。我们只需要在pom.xml中加入数据库依赖，再到application.properties中配置连接信息，不需要像Spring应用中创建JdbcTemplate的Bean，就可以直接在自己的对象中注入使用。")]),e._v(" "),n("p",[n("a",{attrs:{href:"%E6%9C%AC%E6%96%87%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B"}},[e._v("本文完整示例")])])])}]},F={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("p",[e._v("在上一篇"),n("a",{attrs:{href:"/Data/JdbcTemplate"}},[e._v("Spring中使用JdbcTemplate访问数据库")]),e._v(" 中介绍了一种基本的数据访问方式，结合"),n("a",{attrs:{href:"/Web/RESTfulAPI"}},[e._v("构建RESTful API")]),e._v("和"),n("a",{attrs:{href:"/Web/Thymeleaf"}},[e._v("使用Thymeleaf模板引擎渲染Web视图")]),e._v("的内容就已经可以完成App服务端和Web站点的开发任务了。")]),e._v(" "),n("p",[e._v("然而，在实际开发过程中，对数据库的操作无非就“增删改查”。就最为普遍的单表操作而言，除了表和字段不同外，语句都是类似的，开发人员需要写大量类似而枯燥的语句来完成业务逻辑。")]),e._v(" "),n("p",[e._v("为了解决这些大量枯燥的数据操作语句，我们第一个想到的是使用ORM框架，比如：Hibernate。通过整合Hibernate之后，我们以操作Java实体的方式最终将数据改变映射到数据库表中。")]),e._v(" "),n("p",[e._v("为了解决抽象各个Java实体基本的“增删改查”操作，我们通常会以泛型的方式封装一个模板Dao来进行抽象简化，但是这样依然不是很方便，我们需要针对每个实体编写一个继承自泛型模板Dao的接口，再编写该接口的实现。虽然一些基础的数据访问已经可以得到很好的复用，但是在代码结构上针对每个实体都会有一堆Dao的接口和实现。")]),e._v(" "),n("p",[e._v("由于模板Dao的实现，使得这些具体实体的Dao层已经变的非常“薄”，有一些具体实体的Dao实现可能完全就是对模板Dao的简单代理，并且往往这样的实现类可能会出现在很多实体上。Spring-data-jpa的出现正可以让这样一个已经很“薄”的数据访问层变成只是一层接口的编写方式。比如，下面的例子：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('public interface UserRepository extends JpaRepository<User, Long> {\n\n    User findByName(String name);\n\n    @Query("from User u where u.name=:name")\n    User findUser(@Param("name") String name);\n\n}\n')])]),e._v(" "),n("p",[e._v("我们只需要通过编写一个继承自"),n("code",{pre:!0},[e._v("JpaRepository")]),e._v("的接口就能完成数据访问，下面以一个具体实例来体验Spring-data-jpa给我们带来的强大功能。")]),e._v(" "),n("h2",[e._v("使用示例")]),e._v(" "),n("p",[e._v("由于Spring-data-jpa依赖于Hibernate。如果您对Hibernate有一定了解，下面内容可以毫不费力的看懂并上手使用Spring-data-jpa。如果您还是Hibernate新手，您可以先按如下方式入门，再建议回头学习一下Hibernate以帮助这部分的理解和进一步使用。")]),e._v(" "),n("h3",[e._v("工程配置")]),e._v(" "),n("p",[e._v("在"),n("code",{pre:!0},[e._v("pom.xml")]),e._v("中添加相关依赖，加入以下内容：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("<dependency\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-jpa</artifactId>\n</dependency>\n")])]),e._v(" "),n("p",[e._v("在"),n("code",{pre:!0},[e._v("application.xml")]),e._v("中配置：数据库连接信息（如使用嵌入式数据库则不需要）、自动创建表结构的设置，例如使用mysql的情况如下：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("spring.datasource.url=jdbc:mysql://localhost:3306/test\nspring.datasource.username=root\nspring.datasource.password=root\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.jpa.properties.hibernate.hbm2ddl.auto=create-drop\n")])]),e._v(" "),n("p",[n("code",{pre:!0},[e._v("spring.jpa.properties.hibernate.hbm2ddl.auto")]),e._v("是hibernate的配置属性，其主要作用是：自动创建、更新、验证数据库表结构。该参数的几种配置如下：")]),e._v(" "),n("ul",[n("li",[n("code",{pre:!0},[e._v("create")]),e._v("：每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。")]),e._v(" "),n("li",[n("code",{pre:!0},[e._v("create-drop")]),e._v("：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。")]),e._v(" "),n("li",[n("code",{pre:!0},[e._v("update")]),e._v("：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。")]),e._v(" "),n("li",[n("code",{pre:!0},[e._v("validate")]),e._v("：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。")])]),e._v(" "),n("h3",[e._v("创建实体")]),e._v(" "),n("p",[e._v("创建一个User实体，包含id（主键）、name（姓名）、age（年龄）属性，通过ORM框架其会被映射到数据库表中，由于配置了"),n("code",{pre:!0},[e._v("hibernate.hbm2ddl.auto")]),e._v("，在应用启动的时候框架会自动去数据库中创建对应的表。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("@Entity\npublic class User {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(nullable = false)\n    private String name;\n\n    @Column(nullable = false)\n    private Integer age;\n\n    // 省略构造函数\n\n    // 省略getter和setter\n\n}\n")])]),e._v(" "),n("h3",[e._v("创建数据访问接口")]),e._v(" "),n("p",[e._v("下面针对User实体创建对应的"),n("code",{pre:!0},[e._v("Repository")]),e._v("接口实现对该实体的数据访问，如下代码：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('public interface UserRepository extends JpaRepository<User, Long> {\n\n    User findByName(String name);\n\n    User findByNameAndAge(String name, Integer age);\n\n    @Query("from User u where u.name=:name")\n    User findUser(@Param("name") String name);\n\n}\n')])]),e._v(" "),n("p",[e._v("在Spring-data-jpa中，只需要编写类似上面这样的接口就可实现数据访问。不再像我们以往编写了接口时候还需要自己编写接口实现类，直接减少了我们的文件清单。")]),e._v(" "),n("p",[e._v("下面对上面的"),n("code",{pre:!0},[e._v("UserRepository")]),e._v("做一些解释，该接口继承自"),n("code",{pre:!0},[e._v("JpaRepository")]),e._v("，通过查看"),n("code",{pre:!0},[e._v("JpaRepository")]),e._v("接口的"),n("a",{attrs:{href:"https://docs.spring.io/spring-data/data-jpa/docs/current/api/"}},[e._v("API文档")]),e._v("，可以看到该接口本身已经实现了创建（save）、更新（save）、删除（delete）、查询（findAll、findOne）等基本操作的函数，因此对于这些基础操作的数据访问就不需要开发者再自己定义。")]),e._v(" "),n("p",[e._v("在我们实际开发中，"),n("code",{pre:!0},[e._v("JpaRepository")]),e._v("接口定义的接口往往还不够或者性能不够优化，我们需要进一步实现更复杂一些的查询或操作。由于本文重点在spring boot中整合spring-data-jpa，在这里先抛砖引玉简单介绍一下spring-data-jpa中让我们兴奋的功能，后续再单独开篇讲一下spring-data-jpa中的常见使用。")]),e._v(" "),n("p",[e._v("在上例中，我们可以看到下面两个函数：")]),e._v(" "),n("ul",[n("li",[n("code",{pre:!0},[e._v("User findByName(String name)")])]),e._v(" "),n("li",[n("code",{pre:!0},[e._v("User findByNameAndAge(String name, Integer age)")])])]),e._v(" "),n("p",[e._v("它们分别实现了按name查询User实体和按name和age查询User实体，可以看到我们这里没有任何类SQL语句就完成了两个条件查询方法。这就是Spring-data-jpa的一大特性："),n("strong",[e._v("通过解析方法名创建查询")]),e._v("。")]),e._v(" "),n("p",[e._v("除了通过解析方法名来创建查询外，它也提供通过使用@Query 注解来创建查询，您只需要编写JPQL语句，并通过类似“:name”来映射@Param指定的参数，就像例子中的第三个findUser函数一样。")]),e._v(" "),n("p",[n("strong",[e._v("Spring-data-jpa的能力远不止本文提到的这些，由于本文主要以整合介绍为主，对于Spring-data-jpa的使用只是介绍了常见的使用方式。诸如@Modifying操作、分页排序、原生SQL支持以及与Spring MVC的结合使用等等内容就不在本文中详细展开，这里先挖个坑，后续再补文章填坑，如您对这些感兴趣可以关注我博客或简书，同样欢迎大家留言交流想法。")])]),e._v(" "),n("h3",[e._v("单元测试")]),e._v(" "),n("p",[e._v("在完成了上面的数据访问接口之后，按照惯例就是编写对应的单元测试来验证编写的内容是否正确。这里就不多做介绍，主要通过数据操作和查询来反复验证操作的正确性。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('RunWith(SpringJUnit4ClassRunner.class)\n@SpringApplicationConfiguration(Application.class)\npublic class ApplicationTests {\n\n\t@Autowired\n\tprivate UserRepository userRepository;\n\n\t@Test\n\tpublic void test() throws Exception {\n\n\t\t// 创建10条记录\n\t\tuserRepository.save(new User("AAA", 10));\n\t\tuserRepository.save(new User("BBB", 20));\n\t\tuserRepository.save(new User("CCC", 30));\n\t\tuserRepository.save(new User("DDD", 40));\n\t\tuserRepository.save(new User("EEE", 50));\n\t\tuserRepository.save(new User("FFF", 60));\n\t\tuserRepository.save(new User("GGG", 70));\n\t\tuserRepository.save(new User("HHH", 80));\n\t\tuserRepository.save(new User("III", 90));\n\t\tuserRepository.save(new User("JJJ", 100));\n\n\t\t// 测试findAll, 查询所有记录\n\t\tAssert.assertEquals(10, userRepository.findAll().size());\n\n\t\t// 测试findByName, 查询姓名为FFF的User\n\t\tAssert.assertEquals(60, userRepository.findByName("FFF").getAge().longValue());\n\n\t\t// 测试findUser, 查询姓名为FFF的User\n\t\tAssert.assertEquals(60, userRepository.findUser("FFF").getAge().longValue());\n\n\t\t// 测试findByNameAndAge, 查询姓名为FFF并且年龄为60的User\n\t\tAssert.assertEquals("FFF", userRepository.findByNameAndAge("FFF", 60).getName());\n\n\t\t// 测试删除姓名为AAA的User\n\t\tuserRepository.delete(userRepository.findByName("AAA"));\n\n\t\t// 测试findAll, 查询所有记录, 验证上面的删除是否成功\n\t\tAssert.assertEquals(9, userRepository.findAll().size());\n\n\t}\n\n}\n')])]),e._v(" "),n("p",[n("a",{attrs:{href:"%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B"}},[e._v("完整示例")])])])}]},N={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("p",[e._v("之前在介绍使用JdbcTemplate和Spring-data-jpa时，都使用了单数据源。在单数据源的情况下，Spring Boot的配置非常简单，只需要在"),n("code",{pre:!0},[e._v("application.properties")]),e._v("文件中配置连接参数即可。但是往往随着业务量发展，我们通常会进行数据库拆分或是引入其他数据库，从而我们需要配置多个数据源，下面基于之前的JdbcTemplate和Spring-data-jpa例子分别介绍两种多数据源的配置方式。")]),e._v(" "),n("h2",[e._v("多数据源配置")]),e._v(" "),n("p",[e._v("创建一个Spring配置类，定义两个DataSource用来读取"),n("code",{pre:!0},[e._v("application.properties")]),e._v("中的不同配置。如下例子中，主数据源配置为"),n("code",{pre:!0},[e._v("spring.datasource.primary")]),e._v("开头的配置，第二数据源配置为"),n("code",{pre:!0},[e._v("spring.datasource.secondary")]),e._v("开头的配置。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@Configuration\npublic class DataSourceConfig {\n\n    @Bean(name = "primaryDataSource")\n    @Qualifier("primaryDataSource")\n    @ConfigurationProperties(prefix="spring.datasource.primary")\n    public DataSource primaryDataSource() {\n        return DataSourceBuilder.create().build();\n    }\n\n    @Bean(name = "secondaryDataSource")\n    @Qualifier("secondaryDataSource")\n    @Primary\n    @ConfigurationProperties(prefix="spring.datasource.secondary")\n    public DataSource secondaryDataSource() {\n        return DataSourceBuilder.create().build();\n    }\n\n}\n')])]),e._v(" "),n("p",[e._v("对应的"),n("code",{pre:!0},[e._v("application.properties")]),e._v("配置如下：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("spring.datasource.primary.url=jdbc:mysql://localhost:3306/test1\nspring.datasource.primary.username=root\nspring.datasource.primary.password=root\nspring.datasource.primary.driver-class-name=com.mysql.jdbc.Driver\n\nspring.datasource.secondary.url=jdbc:mysql://localhost:3306/test2\nspring.datasource.secondary.username=root\nspring.datasource.secondary.password=root\nspring.datasource.secondary.driver-class-name=com.mysql.jdbc.Driver\n")])]),e._v(" "),n("h3",[e._v("JdbcTemplate支持")]),e._v(" "),n("p",[e._v("对JdbcTemplate的支持比较简单，只需要为其注入对应的datasource即可，如下例子，在创建JdbcTemplate的时候分别注入名为"),n("code",{pre:!0},[e._v("primaryDataSource")]),e._v("和"),n("code",{pre:!0},[e._v("secondaryDataSource")]),e._v("的数据源来区分不同的JdbcTemplate。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@Bean(name = "primaryJdbcTemplate")\npublic JdbcTemplate primaryJdbcTemplate(\n        @Qualifier("primaryDataSource") DataSource dataSource) {\n    return new JdbcTemplate(dataSource);\n}\n\n@Bean(name = "secondaryJdbcTemplate")\npublic JdbcTemplate secondaryJdbcTemplate(\n        @Qualifier("secondaryDataSource") DataSource dataSource) {\n    return new JdbcTemplate(dataSource);\n}\n')])]),e._v(" "),n("p",[e._v("接下来通过测试用例来演示如何使用这两个针对不同数据源的JdbcTemplate。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@RunWith(SpringJUnit4ClassRunner.class)\n@SpringApplicationConfiguration(Application.class)\npublic class ApplicationTests {\n\n\t@Autowired\n\t@Qualifier("primaryJdbcTemplate")\n\tprotected JdbcTemplate jdbcTemplate1;\n\n\t@Autowired\n\t@Qualifier("secondaryJdbcTemplate")\n\tprotected JdbcTemplate jdbcTemplate2;\n\n\t@Before\n\tpublic void setUp() {\n\t\tjdbcTemplate1.update("DELETE  FROM  USER ");\n\t\tjdbcTemplate2.update("DELETE  FROM  USER ");\n\t}\n\n\t@Test\n\tpublic void test() throws Exception {\n\n\t\t// 往第一个数据源中插入两条数据\n\t\tjdbcTemplate1.update("insert into user(id,name,age) values(?, ?, ?)", 1, "aaa", 20);\n\t\tjdbcTemplate1.update("insert into user(id,name,age) values(?, ?, ?)", 2, "bbb", 30);\n\n\t\t// 往第二个数据源中插入一条数据，若插入的是第一个数据源，则会主键冲突报错\n\t\tjdbcTemplate2.update("insert into user(id,name,age) values(?, ?, ?)", 1, "aaa", 20);\n\n\t\t// 查一下第一个数据源中是否有两条数据，验证插入是否成功\n\t\tAssert.assertEquals("2", jdbcTemplate1.queryForObject("select count(1) from user", String.class));\n\n\t\t// 查一下第一个数据源中是否有两条数据，验证插入是否成功\n\t\tAssert.assertEquals("1", jdbcTemplate2.queryForObject("select count(1) from user", String.class));\n\n\t}\n}\n')])]),e._v(" "),n("p",[n("a",{attrs:{href:"http://git.oschina.net/didispace/SpringBoot-Learning"}},[e._v("完整示例:Chapter3-2-3")])]),e._v(" "),n("h3",[e._v("Spring-data-jpa支持")]),e._v(" "),n("p",[e._v("对于数据源的配置可以沿用上例中"),n("code",{pre:!0},[e._v("DataSourceConfig")]),e._v("的实现。")]),e._v(" "),n("p",[e._v("新增对第一数据源的JPA配置，注意两处注释的地方，用于指定数据源对应的"),n("code",{pre:!0},[e._v("Entity")]),e._v("实体和"),n("code",{pre:!0},[e._v("Repository")]),e._v("定义位置，用"),n("code",{pre:!0},[e._v("@Primary")]),e._v("区分主数据源。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@Configuration\n@EnableTransactionManagement\n@EnableJpaRepositories(\n        entityManagerFactoryRef="entityManagerFactoryPrimary",\n        transactionManagerRef="transactionManagerPrimary",\n        basePackages= { "com.didispace.domain.p" }) //设置Repository所在位置\npublic class PrimaryConfig {\n\n    @Autowired @Qualifier("primaryDataSource")\n    private DataSource primaryDataSource;\n\n    @Primary\n    @Bean(name = "entityManagerPrimary")\n    public EntityManager entityManager(EntityManagerFactoryBuilder builder) {\n        return entityManagerFactoryPrimary(builder).getObject().createEntityManager();\n    }\n\n    @Primary\n    @Bean(name = "entityManagerFactoryPrimary")\n    public LocalContainerEntityManagerFactoryBean entityManagerFactoryPrimary (EntityManagerFactoryBuilder builder) {\n        return builder\n                .dataSource(primaryDataSource)\n                .properties(getVendorProperties(primaryDataSource))\n                .packages("com.didispace.domain.p") //设置实体类所在位置\n                .persistenceUnit("primaryPersistenceUnit")\n                .build();\n    }\n\n    @Autowired\n    private JpaProperties jpaProperties;\n\n    private Map<String, String> getVendorProperties(DataSource dataSource) {\n        return jpaProperties.getHibernateProperties(dataSource);\n    }\n\n    @Primary\n    @Bean(name = "transactionManagerPrimary")\n    public PlatformTransactionManager transactionManagerPrimary(EntityManagerFactoryBuilder builder) {\n        return new JpaTransactionManager(entityManagerFactoryPrimary(builder).getObject());\n    }\n}\n')])]),e._v(" "),n("p",[e._v("新增对第二数据源的JPA配置，内容与第一数据源类似，具体如下：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@Configuration\n@EnableTransactionManagement\n@EnableJpaRepositories(\n        entityManagerFactoryRef="entityManagerFactorySecondary",\n        transactionManagerRef="transactionManagerSecondary",\n        basePackages= { "com.didispace.domain.s" }) //设置Repository所在位置\npublic class SecondaryConfig {\n\n    @Autowired @Qualifier("secondaryDataSource")\n    private DataSource secondaryDataSource;\n\n    @Bean(name = "entityManagerSecondary")\n    public EntityManager entityManager(EntityManagerFactoryBuilder builder) {\n        return entityManagerFactorySecondary(builder).getObject().createEntityManager();\n    }\n\n    @Bean(name = "entityManagerFactorySecondary")\n    public LocalContainerEntityManagerFactoryBean entityManagerFactorySecondary (EntityManagerFactoryBuilder builder) {\n        return builder\n                .dataSource(secondaryDataSource)\n                .properties(getVendorProperties(secondaryDataSource))\n                .packages("com.didispace.domain.s") //设置实体类所在位置\n                .persistenceUnit("secondaryPersistenceUnit")\n                .build();\n    }\n\n    @Autowired\n    private JpaProperties jpaProperties;\n\n    private Map<String, String> getVendorProperties(DataSource dataSource) {\n        return jpaProperties.getHibernateProperties(dataSource);\n    }\n\n    @Bean(name = "transactionManagerSecondary")\n    PlatformTransactionManager transactionManagerSecondary(EntityManagerFactoryBuilder builder) {\n        return new JpaTransactionManager(entityManagerFactorySecondary(builder).getObject());\n    }\n}\n')])]),e._v(" "),n("p",[e._v("完成了以上配置之后，主数据源的实体和数据访问对象位于："),n("code",{pre:!0},[e._v("com.didispace.domain.p")]),e._v("，次数据源的实体和数据访问接口位于："),n("code",{pre:!0},[e._v("com.didispace.domain.s")]),e._v("。")]),e._v(" "),n("p",[e._v("分别在这两个package下创建各自的实体和数据访问接口")]),e._v(" "),n("ul",[n("li",[e._v("主数据源下，创建User实体和对应的Repository接口")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("@Entity\npublic class User {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(nullable = false)\n    private String name;\n\n    @Column(nullable = false)\n    private Integer age;\n\n    public User(){}\n\n    public User(String name, Integer age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    // 省略getter、setter\n\n}\n\npublic interface UserRepository extends JpaRepository<User, Long> {\n\n}\n")])]),e._v(" "),n("ul",[n("li",[e._v("从数据源下，创建Message实体和对应的Repository接口")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("@Entity\npublic class Message {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(nullable = false)\n    private String name;\n\n    @Column(nullable = false)\n    private String content;\n\n    public Message(){}\n\n    public Message(String name, String content) {\n        this.name = name;\n        this.content = content;\n    }\n\n    // 省略getter、setter\n\n}\n\npublic interface MessageRepository extends JpaRepository<Message, Long> {\n\n}\n")])]),e._v(" "),n("p",[e._v("接下来通过测试用例来验证使用这两个针对不同数据源的配置进行数据操作。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@RunWith(SpringJUnit4ClassRunner.class)\n@SpringApplicationConfiguration(Application.class)\npublic class ApplicationTests {\n\n\t@Autowired\n\tprivate UserRepository userRepository;\n\t@Autowired\n\tprivate MessageRepository messageRepository;\n\n\t@Test\n\tpublic void test() throws Exception {\n\n\t\tuserRepository.save(new User("aaa", 10));\n\t\tuserRepository.save(new User("bbb", 20));\n\t\tuserRepository.save(new User("ccc", 30));\n\t\tuserRepository.save(new User("ddd", 40));\n\t\tuserRepository.save(new User("eee", 50));\n\n\t\tAssert.assertEquals(5, userRepository.findAll().size());\n\n\t\tmessageRepository.save(new Message("o1", "aaaaaaaaaa"));\n\t\tmessageRepository.save(new Message("o2", "bbbbbbbbbb"));\n\t\tmessageRepository.save(new Message("o3", "cccccccccc"));\n\n\t\tAssert.assertEquals(3, messageRepository.findAll().size());\n\n\t}\n\n}\n')])]),e._v(" "),n("p",[n("a",{attrs:{href:"http://git.oschina.net/didispace/SpringBoot-Learning"}},[e._v("完整示例:Chapter3-2-4")])])])}]},O={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("p",[e._v("Spring Boot中除了对常用的关系型数据库提供了优秀的自动化支持之外，对于很多NoSQL数据库一样提供了自动化配置的支持，包括：Redis, MongoDB, Elasticsearch, Solr和Cassandra。")]),e._v(" "),n("h2",[e._v("使用Redis")]),e._v(" "),n("p",[e._v("Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库。")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"http://redis.io/"}},[e._v("Redis官网")])]),e._v(" "),n("li",[n("a",{attrs:{href:"http://www.redis.cn/"}},[e._v("Redis中文社区")])])]),e._v(" "),n("h3",[e._v("引入依赖")]),e._v(" "),n("p",[e._v("Spring Boot提供的数据访问框架Spring Data Redis基于Jedis。可以通过引入"),n("code",{pre:!0},[e._v("spring-boot-starter-redis")]),e._v("来配置依赖关系。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-redis</artifactId>\n</dependency>\n")])]),e._v(" "),n("h3",[e._v("参数配置")]),e._v(" "),n("p",[e._v("按照惯例在"),n("code",{pre:!0},[e._v("application.properties")]),e._v("中加入Redis服务端的相关配置，具体说明如下：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("# REDIS (RedisProperties)\n# Redis数据库索引（默认为0）\nspring.redis.database=0\n# Redis服务器地址\nspring.redis.host=localhost\n# Redis服务器连接端口\nspring.redis.port=6379\n# Redis服务器连接密码（默认为空）\nspring.redis.password=\n# 连接池最大连接数（使用负值表示没有限制）\nspring.redis.pool.max-active=8\n# 连接池最大阻塞等待时间（使用负值表示没有限制）\nspring.redis.pool.max-wait=-1\n# 连接池中的最大空闲连接\nspring.redis.pool.max-idle=8\n# 连接池中的最小空闲连接\nspring.redis.pool.min-idle=0\n# 连接超时时间（毫秒）\nspring.redis.timeout=0\n")])]),e._v(" "),n("p",[n("strong",[e._v("其中spring.redis.database的配置通常使用0即可，Redis在配置的时候可以设置数据库数量，默认为16，可以理解为数据库的schema")])]),e._v(" "),n("h3",[e._v("测试访问")]),e._v(" "),n("p",[e._v("通过编写测试用例，举例说明如何访问Redis。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@RunWith(SpringJUnit4ClassRunner.class)\n@SpringApplicationConfiguration(Application.class)\npublic class ApplicationTests {\n\n\t@Autowired\n\tprivate StringRedisTemplate stringRedisTemplate;\n\n\t@Test\n\tpublic void test() throws Exception {\n\n\t\t// 保存字符串\n\t\tstringRedisTemplate.opsForValue().set("aaa", "111");\n\t\tAssert.assertEquals("111", stringRedisTemplate.opsForValue().get("aaa"));\n\n    }\n\n}\n')])]),e._v(" "),n("p",[e._v("通过上面这段极为简单的测试案例演示了如何通过自动配置的"),n("code",{pre:!0},[e._v("StringRedisTemplate")]),e._v("对象进行Redis的读写操作，该对象从命名中就可注意到支持的是String类型。如果有使用过spring-data-redis的开发者一定熟悉"),n("code",{pre:!0},[e._v("RedisTemplate<K, V>")]),e._v("接口，"),n("code",{pre:!0},[e._v("StringRedisTemplate")]),e._v("就相当于"),n("code",{pre:!0},[e._v("R")]),e._v("edisTemplate<String, String>``的实现。")]),e._v(" "),n("p",[e._v("除了String类型，实战中我们还经常会在Redis中存储对象，这时候我们就会想是否可以使用类似"),n("code",{pre:!0},[e._v("RedisTemplate<String, User>")]),e._v("来初始化并进行操作。但是Spring Boot并不支持直接使用，需要我们自己实现"),n("code",{pre:!0},[e._v("RedisSerializer<T>")]),e._v("接口来对传入对象进行序列化和反序列化，下面我们通过一个实例来完成对象的读写操作。")]),e._v(" "),n("ul",[n("li",[e._v("创建要存储的对象：User")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("public class User implements Serializable {\n\n    private static final long serialVersionUID = -1L;\n\n    private String username;\n    private Integer age;\n\n    public User(String username, Integer age) {\n        this.username = username;\n        this.age = age;\n    }\n\n    // 省略getter和setter\n\n}\n")])]),e._v(" "),n("ul",[n("li",[e._v("实现对象的序列化接口")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('public class RedisObjectSerializer implements RedisSerializer<Object> {\n\n  private Converter<Object, byte[]> serializer = new SerializingConverter();\n  private Converter<byte[], Object> deserializer = new DeserializingConverter();\n\n  static final byte[] EMPTY_ARRAY = new byte[0];\n\n  public Object deserialize(byte[] bytes) {\n    if (isEmpty(bytes)) {\n      return null;\n    }\n\n    try {\n      return deserializer.convert(bytes);\n    } catch (Exception ex) {\n      throw new SerializationException("Cannot deserialize", ex);\n    }\n  }\n\n  public byte[] serialize(Object object) {\n    if (object == null) {\n      return EMPTY_ARRAY;\n    }\n\n    try {\n      return serializer.convert(object);\n    } catch (Exception ex) {\n      return EMPTY_ARRAY;\n    }\n  }\n\n  private boolean isEmpty(byte[] data) {\n    return (data == null || data.length == 0);\n  }\n}\n')])]),e._v(" "),n("ul",[n("li",[e._v("配置针对User的RedisTemplate实例")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("@Configuration\npublic class RedisConfig {\n\n    @Bean\n    JedisConnectionFactory jedisConnectionFactory() {\n        return new JedisConnectionFactory();\n    }\n\n    @Bean\n    public RedisTemplate<String, User> redisTemplate(RedisConnectionFactory factory) {\n        RedisTemplate<String, User> template = new RedisTemplate<String, User>();\n        template.setConnectionFactory(jedisConnectionFactory());\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setValueSerializer(new RedisObjectSerializer());\n        return template;\n    }\n}\n")])]),e._v(" "),n("ul",[n("li",[e._v("完成了配置工作后，编写测试用例实验效果")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@RunWith(SpringJUnit4ClassRunner.class)\n@SpringApplicationConfiguration(Application.class)\npublic class ApplicationTests {\n\n\t@Autowired\n\tprivate RedisTemplate<String, User> redisTemplate;\n\n\t@Test\n\tpublic void test() throws Exception {\n\n\t\t// 保存对象\n\t\tUser user = new User("超人", 20);\n\t\tredisTemplate.opsForValue().set(user.getUsername(), user);\n\n\t\tuser = new User("蝙蝠侠", 30);\n\t\tredisTemplate.opsForValue().set(user.getUsername(), user);\n\n\t\tuser = new User("蜘蛛侠", 40);\n\t\tredisTemplate.opsForValue().set(user.getUsername(), user);\n\n\t\tAssert.assertEquals(20, redisTemplate.opsForValue().get("超人").getAge().longValue());\n\t\tAssert.assertEquals(30, redisTemplate.opsForValue().get("蝙蝠侠").getAge().longValue());\n\t\tAssert.assertEquals(40, redisTemplate.opsForValue().get("蜘蛛侠").getAge().longValue());\n\n\t}\n\n}\n')])]),e._v(" "),n("p",[e._v("当然spring-data-redis中提供的数据操作远不止这些，本文仅作为在Spring Boot中使用redis时的配置参考，更多对于redis的操作使用，请参考"),n("a",{attrs:{href:"http://docs.spring.io/spring-data/redis/docs/1.6.2.RELEASE/reference/html/"}},[e._v("Spring-data-redis Reference")]),e._v("。")]),e._v(" "),n("p",[n("a",{attrs:{href:"http://git.oschina.net/didispace/SpringBoot-Learning"}},[e._v("本文完整示例chapter3-2-5")])])])}]},q={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("p",[e._v("上文分享了关于"),n("a",{attrs:{href:"/Data/MongoDB"}},[e._v("Spring Boot中使用Redis")]),e._v("的文章，除了Redis之后，我们在互联网产品中还经常会用到另外一款著名的NoSQL数据库MongoDB。")]),e._v(" "),n("p",[e._v("下面就来简单介绍一下MongoDB，并且通过一个例子来介绍Spring Boot中对MongoDB访问的配置和使用。")]),e._v(" "),n("h2",[e._v("MongoDB简介")]),e._v(" "),n("p",[e._v("MongoDB是一个基于分布式文件存储的数据库，它是一个介于关系数据库和非关系数据库之间的产品，其主要目标是在键/值存储方式（提供了高性能和高度伸缩性）和传统的RDBMS系统（具有丰富的功能）之间架起一座桥梁，它集两者的优势于一身。")]),e._v(" "),n("p",[e._v("MongoDB支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型，也因为他的存储格式也使得它所存储的数据在Nodejs程序应用中使用非常流畅。")]),e._v(" "),n("p",[e._v("既然称为NoSQL数据库，Mongo的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。")]),e._v(" "),n("p",[e._v("但是，MongoDB也不是万能的，同MySQL等关系型数据库相比，它们在针对不同的数据类型和事务要求上都存在自己独特的优势。在数据存储的选择中，坚持多样化原则，选择更好更经济的方式，而不是自上而下的统一化。")]),e._v(" "),n("p",[e._v("较常见的，我们可以直接用MongoDB来存储键值对类型的数据，如：验证码、Session等；由于MongoDB的横向扩展能力，也可以用来存储数据规模会在未来变的非常巨大的数据，如：日志、评论等；由于MongoDB存储数据的弱类型，也可以用来存储一些多变json数据，如：与外系统交互时经常变化的JSON报文。而对于一些对数据有复杂的高事务性要求的操作，如：账户交易等就不适合使用MongoDB来存储。")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://www.mongodb.org/"}},[e._v("MongoDB官网")])]),e._v(" "),n("h2",[e._v("访问MongoDB")]),e._v(" "),n("p",[e._v("在Spring Boot中，对如此受欢迎的MongoDB，同样提供了自配置功能。")]),e._v(" "),n("h3",[e._v("引入依赖")]),e._v(" "),n("p",[e._v("Spring Boot中可以通过在"),n("code",{pre:!0},[e._v("pom.xml")]),e._v("中加入"),n("code",{pre:!0},[e._v("spring-boot-starter-data-mongodb")]),e._v("引入对mongodb的访问支持依赖。它的实现依赖"),n("code",{pre:!0},[e._v("spring-data-mongodb")]),e._v("。是的，您没有看错，又是"),n("code",{pre:!0},[e._v("spring-data")]),e._v("的子项目，之前介绍过"),n("code",{pre:!0},[e._v("spring-data-jpa")]),e._v("、"),n("code",{pre:!0},[e._v("spring-data-redis")]),e._v("，对于mongodb的访问，"),n("code",{pre:!0},[e._v("spring-data")]),e._v("也提供了强大的支持，下面就开始动手试试吧。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-mongodb</artifactId>\n</dependency>\n")])]),e._v(" "),n("h3",[e._v("快速开始使用Spring-data-mongodb")]),e._v(" "),n("p",[e._v("若MongoDB的安装配置采用默认端口，那么在自动配置的情况下，我们不需要做任何参数配置，就能马上连接上本地的MongoDB。下面直接使用"),n("code",{pre:!0},[e._v("spring-data-mongodb")]),e._v("来尝试对mongodb的存取操作。（记得mongod启动您的mongodb）")]),e._v(" "),n("ul",[n("li",[e._v("创建要存储的User实体，包含属性：id、username、age")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("public class User {\n\n    @Id\n    private Long id;\n\n    private String username;\n    private Integer age;\n\n    public User(Long id, String username, Integer age) {\n        this.id = id;\n        this.username = username;\n        this.age = age;\n    }\n\n    // 省略getter和setter\n\n}\n")])]),e._v(" "),n("ul",[n("li",[e._v("实现User的数据访问对象：UserRepository")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("public interface UserRepository extends MongoRepository<User, Long> {\n\n    User findByUsername(String username);\n\n}\n")])]),e._v(" "),n("ul",[n("li",[e._v("在单元测试中调用")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('RunWith(SpringJUnit4ClassRunner.class)\n@SpringApplicationConfiguration(Application.class)\npublic class ApplicationTests {\n\n\t@Autowired\n\tprivate UserRepository userRepository;\n\n\t@Before\n\tpublic void setUp() {\n\t\tuserRepository.deleteAll();\n\t}\n\n\t@Test\n\tpublic void test() throws Exception {\n\n\t\t// 创建三个User，并验证User总数\n\t\tuserRepository.save(new User(1L, "didi", 30));\n\t\tuserRepository.save(new User(2L, "mama", 40));\n\t\tuserRepository.save(new User(3L, "kaka", 50));\n\t\tAssert.assertEquals(3, userRepository.findAll().size());\n\n\t\t// 删除一个User，再验证User总数\n\t\tUser u = userRepository.findOne(1L);\n\t\tuserRepository.delete(u);\n\t\tAssert.assertEquals(2, userRepository.findAll().size());\n\n\t\t// 删除一个User，再验证User总数\n\t\tu = userRepository.findByUsername("mama");\n\t\tuserRepository.delete(u);\n\t\tAssert.assertEquals(1, userRepository.findAll().size());\n\n\t}\n\n}\n')])]),e._v(" "),n("h3",[e._v("参数配置")]),e._v(" "),n("p",[e._v("通过上面的例子，我们可以轻而易举的对MongoDB进行访问，但是实战中，应用服务器与MongoDB通常不会部署于同一台设备之上，这样就无法使用自动化的本地配置来进行使用。这个时候，我们也可以方便的配置来完成支持，只需要在application.properties中加入mongodb服务端的相关配置，具体示例如下：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("spring.data.mongodb.uri=mongodb://name:pass@localhost:27017/test\n")])]),e._v(" "),n("p",[e._v("在尝试此配置时，记得在mongo中对test库创建具备读写权限的用户（用户名为name，密码为pass），不同版本的用户创建语句不同，注意查看文档做好准备工作")]),e._v(" "),n("p",[e._v("若使用mongodb 2.x，也可以通过如下参数配置，该方式不支持mongodb 3.x。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("spring.data.mongodb.host=localhost spring.data.mongodb.port=27017\n")])])])}]},J={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("p",[e._v("最近项目原因可能会继续开始使用MyBatis，已经习惯于spring-data的风格，再回头看xml的映射配置总觉得不是特别舒服，接口定义与映射离散在不同文件中，使得阅读起来并不是特别方便。")]),e._v(" "),n("p",[e._v("Spring中整合MyBatis就不多说了，最近大量使用Spring Boot，因此整理一下Spring Boot中整合MyBatis的步骤。搜了一下Spring Boot整合MyBatis的文章，方法都比较老，比较繁琐。查了一下文档，实际已经支持较为简单的整合与使用。下面就来详细介绍如何在Spring Boot中整合MyBatis，并通过注解方式实现映射。")]),e._v(" "),n("h2",[e._v("整合MyBatis")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("新建Spring Boot项目，或以"),n("a",{attrs:{href:"Chapter1"}},[e._v("Chapter1")]),e._v("为基础来操作")])]),e._v(" "),n("li",[n("p",[n("code",{pre:!0},[e._v("pom.xml")]),e._v("中引入依赖")]),e._v(" "),n("ul",[n("li",[e._v("这里用到spring-boot-starter基础和spring-boot-starter-test用来做单元测试验证数据访问")]),e._v(" "),n("li",[e._v("引入连接mysql的必要依赖mysql-connector-java")]),e._v(" "),n("li",[e._v("引入整合MyBatis的核心依赖mybatis-spring-boot-starter")]),e._v(" "),n("li",[e._v("这里不引入spring-boot-starter-jdbc依赖，是由于mybatis-spring-boot-starter中已经包含了此依赖")])])])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("<parent>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-parent</artifactId>\n\t<version>1.3.2.RELEASE</version>\n\t<relativePath/> \x3c!-- lookup parent from repository --\x3e\n</parent>\n\n<dependencies>\n\n\t<dependency>\n\t\t<groupId>org.springframework.boot</groupId>\n\t\t<artifactId>spring-boot-starter</artifactId>\n\t</dependency>\n\n\t<dependency>\n\t\t<groupId>org.springframework.boot</groupId>\n\t\t<artifactId>spring-boot-starter-test</artifactId>\n\t\t<scope>test</scope>\n\t</dependency>\n\n\t<dependency>\n\t\t<groupId>org.mybatis.spring.boot</groupId>\n\t\t<artifactId>mybatis-spring-boot-starter</artifactId>\n\t\t<version>1.1.1</version>\n\t</dependency>\n\n\t<dependency>\n\t\t<groupId>mysql</groupId>\n\t\t<artifactId>mysql-connector-java</artifactId>\n\t\t<version>5.1.21</version>\n\t</dependency>\n\n</dependencies>\n")])]),e._v(" "),n("ul",[n("li",[e._v("同之前介绍的使用jdbc和spring-data连接数据库一样，在"),n("code",{pre:!0},[e._v("application.properties")]),e._v("中配置mysql的连接配置")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("spring.datasource.url=jdbc:mysql://localhost:3306/test\nspring.datasource.username=root\nspring.datasource.password=123456\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\n")])]),e._v(" "),n("p",[e._v("同其他Spring Boot工程一样，简单且简洁的的完成了基本配置，下面看看如何在这个基础下轻松方便的使用MyBatis访问数据库。")]),e._v(" "),n("h2",[e._v("使用MyBatis")]),e._v(" "),n("ul",[n("li",[e._v("在Mysql中创建User表，包含id(BIGINT)、name(INT)、age(VARCHAR)字段。同时，创建映射对象User")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("public class User {\n\n    private Long id;\n    private String name;\n    private Integer age;\n\n    // 省略getter和setter\n\n}\n")])]),e._v(" "),n("ul",[n("li",[e._v("创建User映射的操作UserMapper，为了后续单元测试验证，实现插入和查询操作")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@Mapper\npublic interface UserMapper {\n\n    @Select("SELECT * FROM USER WHERE NAME = #{name}")\n    User findByName(@Param("name") String name);\n\n    @Insert("INSERT INTO USER(NAME, AGE) VALUES(#{name}, #{age})")\n    int insert(@Param("name") String name, @Param("age") Integer age);\n\n}\n')])]),e._v(" "),n("ul",[n("li",[e._v("创建Spring Boot主类")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("@SpringBootApplication\npublic class Application {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Application.class, args);\n\t}\n\n}\n")])]),e._v(" "),n("ul",[n("li",[e._v("创建单元测试\n"),n("ul",[n("li",[e._v("测试逻辑：插入一条name=AAA，age=20的记录，然后根据name=AAA查询，并判断age是否为20")]),e._v(" "),n("li",[e._v("测试结束回滚数据，保证测试单元每次运行的数据环境独立")])])])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@RunWith(SpringJUnit4ClassRunner.class)\n@SpringApplicationConfiguration(classes = Application.class)\npublic class ApplicationTests {\n\n\t@Autowired\n\tprivate UserMapper userMapper;\n\n\t@Test\n\t@Rollback\n\tpublic void findByName() throws Exception {\n\t\tuserMapper.insert("AAA", 20);\n\t\tUser u = userMapper.findByName("AAA");\n\t\tAssert.assertEquals(20, u.getAge().intValue());\n\t}\n\n}\n')])]),e._v(" "),n("p",[e._v("完整示例"),n("a",{attrs:{href:"Chapter3-2-7"}},[e._v("Chapter3-2-7")])])])}]},H={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("p",[e._v("之前在Spring Boot中整合MyBatis时，采用了注解的配置方式，相信很多人还是比较喜欢这种优雅的方式的，也收到不少读者朋友的反馈和问题，主要集中于针对各种场景下注解如何使用，下面就对几种常见的情况举例说明用法。")]),e._v(" "),n("p",[e._v("在做下面的示例之前，先准备一个整合好MyBatis的工程，可参见"),n("a",{attrs:{href:"/Data/MyBatis"}},[e._v("Spring Boot整合MyBatis")]),e._v("，也可直接使用整合好的样例："),n("a",{attrs:{href:"Chapter3-2-7"}},[e._v("Chapter3-2-7")]),e._v("。")]),e._v(" "),n("h2",[e._v("传参方式")]),e._v(" "),n("p",[e._v("下面通过几种不同传参方式来实现前文中实现的插入操作。")]),e._v(" "),n("h3",[e._v("使用@Param")]),e._v(" "),n("p",[e._v("在之前的整合示例中我们已经使用了这种最简单的传参方式，如下：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@Insert("INSERT INTO USER(NAME, AGE) VALUES(#{name}, #{age})")\nint insert(@Param("name") String name, @Param("age") Integer age);\n')])]),e._v(" "),n("p",[e._v("这种方式很好理解，"),n("code",{pre:!0},[e._v("@Param")]),e._v("中定义的"),n("code",{pre:!0},[e._v("name")]),e._v("对应了SQL中的"),n("code",{pre:!0},[e._v("#{name}")]),e._v("，"),n("code",{pre:!0},[e._v("age")]),e._v("对应了SQL中的"),n("code",{pre:!0},[e._v("#{age}")]),e._v("。")]),e._v(" "),n("h3",[e._v("使用Map")]),e._v(" "),n("p",[e._v("如下代码，通过Map对象来作为传递参数的容器：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@Insert("INSERT INTO USER(NAME, AGE) VALUES(#{name,jdbcType=VARCHAR}, #{age,jdbcType=INTEGER})")\nint insertByMap(Map<String, Object> map);\n')])]),e._v(" "),n("p",[e._v("对于Insert语句中需要的参数，我们只需要在map中填入同名的内容即可，具体如下面代码所示：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('Map<String, Object> map = new HashMap<>();\nmap.put("name", "CCC");\nmap.put("age", 40);\nuserMapper.insertByMap(map);\n')])]),e._v(" "),n("h3",[e._v("使用对象")]),e._v(" "),n("p",[e._v("除了Map对象，我们也可直接使用普通的Java对象来作为查询条件的传参，比如我们可以直接使用User对象:")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@Insert("INSERT INTO USER(NAME, AGE) VALUES(#{name}, #{age})")\nint insertByUser(User user);\n')])]),e._v(" "),n("p",[e._v("这样语句中的"),n("code",{pre:!0},[e._v("#{name}")]),e._v("、"),n("code",{pre:!0},[e._v("#{age}")]),e._v("就分别对应了User对象中的"),n("code",{pre:!0},[e._v("name")]),e._v("和"),n("code",{pre:!0},[e._v("age")]),e._v("属性。")]),e._v(" "),n("h2",[e._v("增删改查")]),e._v(" "),n("p",[e._v("MyBatis针对不同的数据库操作分别提供了不同的注解来进行配置，在之前的示例中演示了"),n("code",{pre:!0},[e._v("@Insert")]),e._v("，下面针对User表做一组最基本的增删改查作为示例：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('public interface UserMapper {\n\n    @Select("SELECT * FROM user WHERE name = #{name}")\n    User findByName(@Param("name") String name);\n\n    @Insert("INSERT INTO user(name, age) VALUES(#{name}, #{age})")\n    int insert(@Param("name") String name, @Param("age") Integer age);\n\n    @Update("UPDATE user SET age=#{age} WHERE name=#{name}")\n    void update(User user);\n\n    @Delete("DELETE FROM user WHERE id =#{id}")\n    void delete(Long id);\n}\n')])]),e._v(" "),n("p",[e._v("在完成了一套增删改查后，不妨我们试试下面的单元测试来验证上面操作的正确性：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@RunWith(SpringJUnit4ClassRunner.class)\n@SpringApplicationConfiguration(classes = Application.class)\n@Transactional\npublic class ApplicationTests {\n\n\t@Autowired\n\tprivate UserMapper userMapper;\n\n\t@Test\n\t@Rollback\n\tpublic void testUserMapper() throws Exception {\n\t\t// insert一条数据，并select出来验证\n\t\tuserMapper.insert("AAA", 20);\n\t\tUser u = userMapper.findByName("AAA");\n\t\tAssert.assertEquals(20, u.getAge().intValue());\n\t\t// update一条数据，并select出来验证\n\t\tu.setAge(30);\n\t\tuserMapper.update(u);\n\t\tu = userMapper.findByName("AAA");\n\t\tAssert.assertEquals(30, u.getAge().intValue());\n\t\t// 删除这条数据，并select验证\n\t\tuserMapper.delete(u.getId());\n\t\tu = userMapper.findByName("AAA");\n\t\tAssert.assertEquals(null, u);\n\t}\n}\n')])]),e._v(" "),n("h2",[e._v("返回结果的绑定")]),e._v(" "),n("p",[e._v("对于增、删、改操作相对变化较小。而对于“查”操作，我们往往需要进行多表关联，汇总计算等操作，那么对于查询的结果往往就不再是简单的实体对象了，往往需要返回一个与数据库实体不同的包装类，那么对于这类情况，就可以通过"),n("code",{pre:!0},[e._v("@Results")]),e._v("和"),n("code",{pre:!0},[e._v("@Result")]),e._v("注解来进行绑定，具体如下：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@Results({\n    @Result(property = "name", column = "name"),\n    @Result(property = "age", column = "age")\n})\n@Select("SELECT name, age FROM user")\nList<User> findAll();\n')])]),e._v(" "),n("p",[e._v("在上面代码中，@Result中的property属性对应User对象中的成员名，column对应SELECT出的字段名。在该配置中故意没有查出id属性，只对User对应中的name和age对象做了映射配置，这样可以通过下面的单元测试来验证查出的id为null，而其他属性不为null：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("@Test\n@Rollback\npublic void testUserMapper() throws Exception {\n\tList<User> userList = userMapper.findAll();\n\tfor(User user : userList) {\n\t\tAssert.assertEquals(null, user.getId());\n\t\tAssert.assertNotEquals(null, user.getName());\n\t}\n}\n")])]),e._v(" "),n("h2",[e._v("Spring Boot中增强对MongoDB的配置（连接池等）")]),e._v(" "),n("h3",[e._v("spring-boot-starter-mongodb-plus使用")]),e._v(" "),n("ol",[n("li",[e._v("在使用了"),n("code",{pre:!0},[e._v("spring-boot-starter-data-mongodb")]),e._v("的项目中，增加以下依赖")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("<dependency>\n    <groupId>com.spring4all</groupId>\n    <artifactId>mongodb-plus-spring-boot-starter</artifactId>\n    <version>1.0.0.RELEASE</version>\n</dependency>\n")])]),e._v(" "),n("ol",[n("li",[e._v("在应用主类上增加"),n("code",{pre:!0},[e._v("@EnableMongoPlus")]),e._v("注解，比如：")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("@EnableMongoPlus\n@SpringBootApplication\npublic class Application {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n\n}\n")])]),e._v(" "),n("h3",[e._v("可用配置参数")]),e._v(" "),n("p",[e._v("可配置参数如下：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("spring.data.mongodb.option.min-connection-per-host=0\nspring.data.mongodb.option.max-connection-per-host=100\nspring.data.mongodb.option.threads-allowed-to-block-for-connection-multiplier=5\nspring.data.mongodb.option.server-selection-timeout=30000\nspring.data.mongodb.option.max-wait-time=120000\nspring.data.mongodb.option.max-connection-idle-time=0\nspring.data.mongodb.option.max-connection-life-time=0\nspring.data.mongodb.option.connect-timeout=10000\nspring.data.mongodb.option.socket-timeout=0\n\nspring.data.mongodb.option.socket-keep-alive=false\nspring.data.mongodb.option.ssl-enabled=false\nspring.data.mongodb.option.ssl-invalid-host-name-allowed=false\nspring.data.mongodb.option.always-use-m-beans=false\n\nspring.data.mongodb.option.heartbeat-socket-timeout=20000\nspring.data.mongodb.option.heartbeat-connect-timeout=20000\nspring.data.mongodb.option.min-heartbeat-frequency=500\nspring.data.mongodb.option.heartbeat-frequency=10000\nspring.data.mongodb.option.local-threshold=15\n")])]),e._v(" "),n("p",[n("em",[e._v("上述配置值均为默认值")])]),e._v(" "),n("h2",[e._v("后记")]),e._v(" "),n("p",[e._v("本文主要介绍几种最为常用的方式，更多其他注解的使用可参见文档：\n"),n("a",{attrs:{href:"http://www.mybatis.org/mybatis-3/zh/java-api.html"}},[e._v("http://www.mybatis.org/mybatis-3/zh/java-api.html")])]),e._v(" "),n("p",[e._v("本文示例完整代码："),n("a",{attrs:{href:"Chapter3-2-8"}},[e._v("Chapter3-2-8")])])])}]},$={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("h2",[e._v("Flyway简介")]),e._v(" "),n("p",[e._v("Flyway是一个简单开源数据库版本控制器（约定大于配置），主要提供migrate、clean、info、validate、baseline、repair等命令。它支持SQL（PL/SQL、T-SQL）方式和Java方式，支持命令行客户端等，还提供一系列的插件支持（Maven、Gradle、SBT、ANT等）。")]),e._v(" "),n("p",[e._v("官方网站："),n("a",{attrs:{href:"https://flywaydb.org/"}},[e._v("https://flywaydb.org/")])]),e._v(" "),n("p",[e._v("本文对于Flyway的自身功能不做过多的介绍，读者可以通过阅读官方文档或利用搜索引擎获得更多资料。下面我们具体说说在Spring Boot应用中的应用，如何使用Flyway来创建数据库以及结构不一致的检查。")]),e._v(" "),n("h2",[e._v("动手试一试")]),e._v(" "),n("p",[e._v("下面我们可以通过对"),n("a",{attrs:{href:"http://blog.didispace.com/springbootdata1/"}},[e._v("使用JdbcTemplate")]),e._v("一文中的例子进行加工完成。读者也可以拿任何一个与数据访问相关的工程来做如下内容的实验：")]),e._v(" "),n("ul",[n("li",[e._v("第一步，在"),n("code",{pre:!0},[e._v("pom.xml")]),e._v("中增加flyway的依赖：")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("<dependency>\n\t<groupId>org.flywaydb</groupId>\n\t<artifactId>flyway-core</artifactId>\n\t<version>5.0.3</version>\n</dependency>\n")])]),e._v(" "),n("ul",[n("li",[e._v("第二步，按Flyway的规范创建版本化的SQL脚本。\n"),n("ul",[n("li",[e._v("在工程的"),n("code",{pre:!0},[e._v("src/main/resources")]),e._v("目录下创建"),n("code",{pre:!0},[e._v("db")]),e._v("目录")]),e._v(" "),n("li",[e._v("在"),n("code",{pre:!0},[e._v("db")]),e._v("目录下创建版本化的SQL脚本"),n("code",{pre:!0},[e._v("V1__Base_version.sql")])])])])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("DROP TABLE IF EXISTS user ;\nCREATE TABLE `user` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `name` varchar(20) NOT NULL COMMENT '姓名',\n  `age` int(5) DEFAULT NULL COMMENT '年龄',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n")])]),e._v(" "),n("ul",[n("li",[e._v("第三步，在"),n("code",{pre:!0},[e._v("application.properties")]),e._v("文件中配置Flyway要加载的SQL脚本位置。按第二步创建的结果配置如下：")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("flyway.locations=classpath:/db\n")])]),e._v(" "),n("ul",[n("li",[e._v("第四步，执行单元测试"),n("code",{pre:!0},[e._v("ApplicationTests")]),e._v("，此时我们在日志中可以看到如下信息：")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("INFO 82441 --- [main] o.f.core.internal.util.VersionPrinter    : Flyway Community Edition 5.0.3 by Boxfuse\nINFO 82441 --- [main] o.f.c.internal.database.DatabaseFactory  : Database: jdbc:mysql://localhost:3306/test (MySQL 5.7)\nINFO 82441 --- [main] o.f.core.internal.command.DbValidate     : Successfully validated 1 migration (execution time 00:00.022s)\nINFO 82441 --- [main] o.f.c.i.s.JdbcTableSchemaHistory         : Creating Schema History table: `test`.`flyway_schema_history`\nINFO 82441 --- [main] o.f.core.internal.command.DbMigrate      : Current version of schema `test`: << Empty Schema >>\nINFO 82441 --- [main] o.f.core.internal.command.DbMigrate      : Migrating schema `test` to version 1 - Base version\nWARN 82441 --- [main] o.f.core.internal.sqlscript.SqlScript    : DB: Unknown table 'test.user' (SQL State: 42S02 - Error Code: 1051)\nINFO 82441 --- [main] o.f.core.internal.command.DbMigrate      : Successfully applied 1 migration to schema `test` (execution time 00:00.128s)\n")])]),e._v(" "),n("p",[e._v("Flyway监测到需要运行版本脚本来初始化数据库，因此执行了"),n("code",{pre:!0},[e._v("V1__Base_version.sql")]),e._v("脚本，从而创建了user表，这才得以让一系列单元测试（对user表的CRUD操作）通过。")]),e._v(" "),n("ul",[n("li",[e._v("第五步，我们可以继续再执行一下单元测试，此时我们会发现日志输出与之前不同：")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("INFO 83150 --- [main] o.f.core.internal.util.VersionPrinter    : Flyway Community Edition 5.0.3 by Boxfuse\nINFO 83150 --- [main] o.f.c.internal.database.DatabaseFactory  : Database: jdbc:mysql://localhost:3306/test (MySQL 5.7)\nINFO 83150 --- [main] o.f.core.internal.command.DbValidate     : Successfully validated 1 migration (execution time 00:00.031s)\nINFO 83150 --- [main] o.f.core.internal.command.DbMigrate      : Current version of schema `test`: 1\nINFO 83150 --- [main] o.f.core.internal.command.DbMigrate      : Schema `test` is up to date. No migration necessary.\n")])]),e._v(" "),n("p",[e._v("由于在第四步的时候，初始化脚本已经执行过，所以这次执行就没有再去执行"),n("code",{pre:!0},[e._v("V1__Base_version.sql")]),e._v("脚本来重建user表。")]),e._v(" "),n("ul",[n("li",[e._v("第六步，我们可以尝试修改一下"),n("code",{pre:!0},[e._v("V1__Base_version.sql")]),e._v("脚本中的name字段长度，然后在运行一下单元测试，此时我们可以得到如下错误：")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("ERROR 83791 --- [main] o.s.boot.SpringApplication               : Application startup failed\n\norg.springframework.beans.factory.BeanCreationException: Error creating bean with name 'flywayInitializer' defined in class path resource [org/springframework/boot/autoconfigure/flyway/FlywayAutoConfiguration$FlywayConfiguration.class]: Invocation of init method failed; nested exception is org.flywaydb.core.api.FlywayException: Validate failed: Migration checksum mismatch for migration version 1\n-> Applied to database : 466264992\n-> Resolved locally    : -270269434\n")])]),e._v(" "),n("p",[e._v("由于初始化脚本的改动，Flyway校验失败，认为当前的"),n("code",{pre:!0},[e._v("V1__Base_version.sql")]),e._v("脚本与上一次执行的内容不同，提示报错并终止程序，以免造成更严重的数据结构破坏。")]),e._v(" "),n("h2",[e._v("总结")]),e._v(" "),n("p",[e._v("到这里为止，本文的内容告一段落。由于博文篇幅问题，对于Flyway更细节的使用没有说的太多，本文主要作为敲门砖，帮助和引导正在使用Spring Boot做系统开发的个人或团队在数据库的版本控制上做的更好提供一些思路。至于更深入的应用还请读者自行翻阅官方文档参考和学习。")]),e._v(" "),n("p",[n("a",{attrs:{href:"%E6%9C%AC%E6%96%87%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B"}},[e._v("本文完整示例")])])])}]},W={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("blockquote",[n("p",[e._v("很多时候，我们在构建系统的时候都会自己创建用户管理体系，这对于开发人员来说并不是什么难事，但是当我们需要维护多个不同系统并且相同用户跨系统使用的情况下，如果每个系统维护自己的用户信息，那么此时用户信息的同步就会变的比较麻烦，对于用户自身来说也会非常困扰，很容易出现不同系统密码不一致啊等情况出现。如果此时我们引入LDAP来集中存储用户的基本信息并提供统一的读写接口和校验机制，那么这样的问题就比较容易解决了。下面就来说说当我们使用Spring Boot开发的时候，如何来访问LDAP服务端。")])]),e._v(" "),n("h2",[e._v("LDAP简介")]),e._v(" "),n("p",[e._v("LDAP（轻量级目录访问协议，Lightweight Directory Access Protocol)是实现提供被称为目录服务的信息服务。目录服务是一种特殊的数据库系统，其专门针对读取，浏览和搜索操作进行了特定的优化。目录一般用来包含描述性的，基于属性的信息并支持精细复杂的过滤能力。目录一般不支持通用数据库针对大量更新操作操作需要的复杂的事务管理或回卷策略。而目录服务的更新则一般都非常简单。这种目录可以存储包括个人信息、web链结、jpeg图像等各种信息。为了访问存储在目录中的信息，就需要使用运行在TCP/IP 之上的访问协议—LDAP。")]),e._v(" "),n("p",[e._v("LDAP目录中的信息是是按照树型结构组织，具体信息存储在条目(entry)的数据结构中。条目相当于关系数据库中表的记录；条目是具有区别名DN （Distinguished Name）的属性（Attribute），DN是用来引用条目的，DN相当于关系数据库表中的关键字（Primary Key）。属性由类型（Type）和一个或多个值（Values）组成，相当于关系数据库中的字段（Field）由字段名和数据类型组成，只是为了方便检索的需要，LDAP中的Type可以有多个Value，而不是关系数据库中为降低数据的冗余性要求实现的各个域必须是不相关的。LDAP中条目的组织一般按照地理位置和组织关系进行组织，非常的直观。LDAP把数据存放在文件中，为提高效率可以使用基于索引的文件数据库，而不是关系数据库。类型的一个例子就是mail，其值将是一个电子邮件地址。")]),e._v(" "),n("p",[e._v("LDAP的信息是以树型结构存储的，在树根一般定义国家(c=CN)或域名(dc=com)，在其下则往往定义一个或多个组织 (organization)(o=Acme)或组织单元(organizational units) (ou=People)。一个组织单元可能包含诸如所有雇员、大楼内的所有打印机等信息。此外，LDAP支持对条目能够和必须支持哪些属性进行控制，这是有一个特殊的称为对象类别(objectClass)的属性来实现的。该属性的值决定了该条目必须遵循的一些规则，其规定了该条目能够及至少应该包含哪些属性。例如：inetorgPerson对象类需要支持sn(surname)和cn(common name)属性，但也可以包含可选的如邮件，电话号码等属性。")]),e._v(" "),n("h3",[e._v("LDAP简称对应")]),e._v(" "),n("ul",[n("li",[e._v("o：organization（组织-公司）")]),e._v(" "),n("li",[e._v("ou：organization unit（组织单元-部门）")]),e._v(" "),n("li",[e._v("c：countryName（国家）")]),e._v(" "),n("li",[e._v("dc：domainComponent（域名）")]),e._v(" "),n("li",[e._v("sn：surname（姓氏）")]),e._v(" "),n("li",[e._v("cn：common name（常用名称）")])]),e._v(" "),n("p",[n("em",[e._v("以上内容参考自")]),e._v("："),n("a",{attrs:{href:"https://www.cnblogs.com/obpm/archive/2010/08/28/1811065.html"}},[e._v("LDAP快速入门")])]),e._v(" "),n("h2",[e._v("入门示例")]),e._v(" "),n("p",[e._v("在了解了LDAP的基础概念之后，我们通过一个简单例子进一步理解！")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("创建一个基础的Spring Boot项目")])]),e._v(" "),n("li",[n("p",[e._v("在"),n("code",{pre:!0},[e._v("pom.xml")]),e._v("中引入两个重要依赖")])])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-ldap</artifactId>\n</dependency>\n\n<dependency>\n    <groupId>com.unboundid</groupId>\n    <artifactId>unboundid-ldapsdk</artifactId>\n    <scope>test</scope>\n</dependency>\n")])]),e._v(" "),n("p",[e._v("其中，"),n("code",{pre:!0},[e._v("spring-boot-starter-data-ldap")]),e._v("是Spring Boot封装的对LDAP自动化配置的实现，它是基于spring-data-ldap来对LDAP服务端进行具体操作的。")]),e._v(" "),n("p",[e._v("而"),n("code",{pre:!0},[e._v("unboundid-ldapsdk")]),e._v("主要是为了在这里使用嵌入式的LDAP服务端来进行测试操作，所以scope设置为了test，实际应用中，我们通常会连接真实的、独立部署的LDAP服务器，所以不需要此项依赖。")]),e._v(" "),n("ul",[n("li",[e._v("在"),n("code",{pre:!0},[e._v("src/test/resources")]),e._v("目录下创建"),n("code",{pre:!0},[e._v("ldap-server.ldif")]),e._v("文件，用来存储LDAP服务端的基础数据，以备后面的程序访问之用。")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("dn: dc=didispace,dc=com\nobjectClass: top\nobjectClass: domain\n\ndn: ou=people,dc=didispace,dc=com\nobjectclass: top\nobjectclass: organizationalUnit\nou: people\n\ndn: uid=ben,ou=people,dc=didispace,dc=com\nobjectclass: top\nobjectclass: person\nobjectclass: organizationalPerson\nobjectclass: inetOrgPerson\ncn: didi\nsn: zhaiyongchao\nuid: didi\nuserPassword: {SHA}nFCebWjxfaLbHHG1Qk5UU4trbvQ=\n")])]),e._v(" "),n("p",[e._v("这里创建了一个基础用户，真实姓名为"),n("code",{pre:!0},[e._v("zhaiyongchao")]),e._v(",常用名"),n("code",{pre:!0},[e._v("didi")]),e._v("，在后面的程序中，我们会来读取这些信息。更多内容解释大家可以深入学习LDAP来理解，这里不做过多的讲解。")]),e._v(" "),n("ul",[n("li",[e._v("在"),n("code",{pre:!0},[e._v("application.properties")]),e._v("中添加嵌入式LDAP的配置")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("spring.ldap.embedded.ldif=ldap-server.ldif\nspring.ldap.embedded.base-dn=dc=didispace,dc=com\n")])]),e._v(" "),n("ul",[n("li",[e._v("使用spring-data-ldap的基础用法，定义LDAP中属性与我们Java中定义实体的关系映射以及对应的Repository")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@Data\n@Entry(base = "ou=people,dc=didispace,dc=com", objectClasses = "inetOrgPerson")\npublic class Person {\n\n    @Id\n    private Name id;\n    @DnAttribute(value = "uid", index = 3)\n    private String uid;\n    @Attribute(name = "cn")\n    private String commonName;\n    @Attribute(name = "sn")\n    private String suerName;\n    private String userPassword;\n\n}\n\npublic interface PersonRepository extends CrudRepository<Person, Name> {\n\n}\n')])]),e._v(" "),n("p",[e._v("通过上面的定义之后，已经将Person对象与LDAP存储内容实现了映射，我们只需要使用"),n("code",{pre:!0},[e._v("PersonRepository")]),e._v("就可以轻松的对LDAP内容实现读写。")]),e._v(" "),n("ul",[n("li",[e._v("创建单元测试用例读取所有用户信息：")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class ApplicationTests {\n\n\t@Autowired\n\tprivate PersonRepository personRepository;\n\n\t@Test\n\tpublic void findAll() throws Exception {\n\t\tpersonRepository.findAll().forEach(p -> {\n\t\t\tSystem.out.println(p);\n\t\t});\n\t}\n}\n")])]),e._v(" "),n("p",[e._v("启动该测试用例之后，我们可以看到控制台中输出了刚才维护在"),n("code",{pre:!0},[e._v("ldap-server.ldif")]),e._v("中的用户信息：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("2018-01-27 14:25:06.283  WARN 73630 --- [           main] o.s.ldap.odm.core.impl.ObjectMetaData    : The Entry class Person should be declared final\nPerson(id=uid=ben,ou=people,dc=didispace,dc=com, uid=ben, commonName=didi, suerName=zhaiyongchao, userPassword=123,83,72,65,125,110,70,67,101,98,87,106,120,102,97,76,98,72,72,71,49,81,107,53,85,85,52,116,114,98,118,81,61)\n")])]),e._v(" "),n("h3",[e._v("添加用户")]),e._v(" "),n("p",[e._v("通过上面的入门示例，如果您能够独立完成，那么在Spring Boot中操作LDAP的基础目标已经完成了。")]),e._v(" "),n("p",[e._v("如果您足够了解Spring Data，其实不难想到，这个在其下的子项目必然也遵守Repsitory的抽象。所以，我们可以使用上面定义的"),n("code",{pre:!0},[e._v("PersonRepository")]),e._v("来轻松实现操作，比如下面的代码就可以方便的往LDAP中添加用户：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('Person person = new Person();\nperson.setUid("uid:1");\nperson.setSuerName("AAA");\nperson.setCommonName("aaa");\nperson.setUserPassword("123456");\npersonRepository.save(person);\n')])]),e._v(" "),n("p",[e._v("如果还想实现更多操作，您可以参考spring-data-ldap的文档来进行使用。")]),e._v(" "),n("h3",[e._v("连接LDAP服务端")]),e._v(" "),n("p",[e._v("在本文的例子中都采用了嵌入式的LDAP服务器，事实上这种方式也仅限于我们本地测试开发使用，真实环境下LDAP服务端必然是独立部署的。")]),e._v(" "),n("p",[e._v("在Spring Boot的封装下，我们只需要配置下面这些参数就能将上面的例子连接到远端的LDAP而不是嵌入式的LDAP。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("spring.ldap.urls=ldap://localhost:1235\nspring.ldap.base=dc=didispace,dc=com\nspring.ldap.username=didispace\nspring.ldap.password=123456\n")])]),e._v(" "),n("h2",[e._v("本文代码")]),e._v(" "),n("p",[e._v("可以通过下面两个仓库中查阅"),n("code",{pre:!0},[e._v("chapter3-2-10")]),e._v("目录：")]),e._v(" "),n("p",[n("a",{attrs:{href:"%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B"}},[e._v("完整示例")])])])}]},V={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("h2",[e._v("什么是事务？")]),e._v(" "),n("p",[e._v("我们在开发企业应用时，对于业务人员的一个操作实际是对数据读写的多步操作的结合。由于数据操作在顺序执行的过程中，任何一步操作都有可能发生异常，异常会导致后续操作无法完成，此时由于业务逻辑并未正确的完成，之前成功操作数据的并不可靠，需要在这种情况下进行回退。")]),e._v(" "),n("p",[e._v("事务的作用就是为了保证用户的每一个操作都是可靠的，事务中的每一步操作都必须成功执行，只要有发生异常就回退到事务开始未进行操作的状态。")]),e._v(" "),n("p",[e._v("事务管理是Spring框架中最为常用的功能之一，我们在使用Spring Boot开发应用时，大部分情况下也都需要使用事务。")]),e._v(" "),n("h2",[e._v("快速入门")]),e._v(" "),n("p",[e._v("在Spring Boot中，当我们使用了spring-boot-starter-jdbc或spring-boot-starter-data-jpa依赖的时候，框架会自动默认分别注入DataSourceTransactionManager或JpaTransactionManager。所以我们不需要任何额外配置就可以用@Transactional注解进行事务的使用。")]),e._v(" "),n("p",[e._v("我们以之前实现的《用spring-data-jpa访问数据库》的示例"),n("a",{attrs:{href:"Chapter3-2-2"}},[e._v("Chapter3-2-2")]),e._v("作为基础工程进行事务的使用常识。")]),e._v(" "),n("p",[e._v("在该样例工程中（若对该数据访问方式不了解，可先阅读该"),n("a",{attrs:{href:"/Data/Jpa"}},[e._v("文章")]),e._v("），我们引入了spring-data-jpa，并创建了User实体以及对User的数据访问对象UserRepository，在ApplicationTest类中实现了使用UserRepository进行数据读写的单元测试用例，如下：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@RunWith(SpringJUnit4ClassRunner.class)\n@SpringApplicationConfiguration(Application.class)\npublic class ApplicationTests {\n\n\t@Autowired\n\tprivate UserRepository userRepository;\n\n\t@Test\n\tpublic void test() throws Exception {\n\n\t\t// 创建10条记录\n\t\tuserRepository.save(new User("AAA", 10));\n\t\tuserRepository.save(new User("BBB", 20));\n\t\tuserRepository.save(new User("CCC", 30));\n\t\tuserRepository.save(new User("DDD", 40));\n\t\tuserRepository.save(new User("EEE", 50));\n\t\tuserRepository.save(new User("FFF", 60));\n\t\tuserRepository.save(new User("GGG", 70));\n\t\tuserRepository.save(new User("HHH", 80));\n\t\tuserRepository.save(new User("III", 90));\n\t\tuserRepository.save(new User("JJJ", 100));\n\n\t\t// 省略后续的一些验证操作\n\t}\n}\n')])]),e._v(" "),n("p",[e._v("可以看到，在这个单元测试用例中，使用UserRepository对象连续创建了10个User实体到数据库中，下面我们人为的来制造一些异常，看看会发生什么情况。")]),e._v(" "),n("p",[e._v("通过定义User的name属性长度为5，这样通过创建时User实体的name属性超长就可以触发异常产生。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("@Entity\npublic class User {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(nullable = false, length = 5)\n    private String name;\n\n    @Column(nullable = false)\n    private Integer age;\n\n    // 省略构造函数、getter和setter\n\n}\n")])]),e._v(" "),n("p",[e._v("修改测试用例中创建记录的语句，将一条记录的name长度超过5，如下：name为HHHHHHHHH的User对象将会抛出异常。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('// 创建10条记录\nuserRepository.save(new User("AAA", 10));\nuserRepository.save(new User("BBB", 20));\nuserRepository.save(new User("CCC", 30));\nuserRepository.save(new User("DDD", 40));\nuserRepository.save(new User("EEE", 50));\nuserRepository.save(new User("FFF", 60));\nuserRepository.save(new User("GGG", 70));\nuserRepository.save(new User("HHHHHHHHHH", 80));\nuserRepository.save(new User("III", 90));\nuserRepository.save(new User("JJJ", 100));\n')])]),e._v(" "),n("p",[e._v("执行测试用例，可以看到控制台中抛出了如下异常，name字段超长：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("2016-05-27 10:30:35.948  WARN 2660 --- [           main] o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Error: 1406, SQLState: 22001\n2016-05-27 10:30:35.948 ERROR 2660 --- [           main] o.h.engine.jdbc.spi.SqlExceptionHelper   : Data truncation: Data too long for column 'name' at row 1\n2016-05-27 10:30:35.951  WARN 2660 --- [           main] o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Warning Code: 1406, SQLState: HY000\n2016-05-27 10:30:35.951  WARN 2660 --- [           main] o.h.engine.jdbc.spi.SqlExceptionHelper   : Data too long for column 'name' at row 1\n\norg.springframework.dao.DataIntegrityViolationException: could not execute statement; SQL [n/a]; nested exception is org.hibernate.exception.DataException: could not execute statement\n")])]),e._v(" "),n("p",[e._v("此时查数据库中，创建了name从AAA到GGG的记录，没有HHHHHHHHHH、III、JJJ的记录。而若这是一个希望保证完整性操作的情况下，AAA到GGG的记录希望能在发生异常的时候被回退，这时候就可以使用事务让它实现回退，做法非常简单，我们只需要在test函数上添加"),n("code",{pre:!0},[e._v("@Transactional")]),e._v("注解即可。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("@Test\n@Transactional\npublic void test() throws Exception {\n\n    // 省略测试内容\n\n}\n")])]),e._v(" "),n("p",[e._v("再来执行该测试用例，可以看到控制台中输出了回滚日志（Rolled back transaction for test context）")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("2016-05-27 10:35:32.210  WARN 5672 --- [           main] o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Error: 1406, SQLState: 22001\n2016-05-27 10:35:32.210 ERROR 5672 --- [           main] o.h.engine.jdbc.spi.SqlExceptionHelper   : Data truncation: Data too long for column 'name' at row 1\n2016-05-27 10:35:32.213  WARN 5672 --- [           main] o.h.engine.jdbc.spi.SqlExceptionHelper   : SQL Warning Code: 1406, SQLState: HY000\n2016-05-27 10:35:32.213  WARN 5672 --- [           main] o.h.engine.jdbc.spi.SqlExceptionHelper   : Data too long for column 'name' at row 1\n2016-05-27 10:35:32.221  INFO 5672 --- [           main] o.s.t.c.transaction.TransactionContext   : Rolled back transaction for test context [DefaultTestContext@1d7a715 testClass = ApplicationTests, testInstance = com.didispace.ApplicationTests@95a785, testMethod = test@ApplicationTests, testException = org.springframework.dao.DataIntegrityViolationException: could not execute statement; SQL [n/a]; nested exception is org.hibernate.exception.DataException: could not execute statement, mergedContextConfiguration = [MergedContextConfiguration@11f39f9 testClass = ApplicationTests, locations = '{}', classes = '{class com.didispace.Application}', contextInitializerClasses = '[]', activeProfiles = '{}', propertySourceLocations = '{}', propertySourceProperties = '{}', contextLoader = 'org.springframework.boot.test.SpringApplicationContextLoader', parent = [null]]].\n\norg.springframework.dao.DataIntegrityViolationException: could not execute statement; SQL [n/a]; nested exception is org.hibernate.exception.DataException: could not execute statement\n")])]),e._v(" "),n("p",[e._v("再看数据库中，User表就没有AAA到GGG的用户数据了，成功实现了自动回滚。")]),e._v(" "),n("p",[e._v("这里主要通过单元测试演示了如何使用"),n("code",{pre:!0},[e._v("@Transactional")]),e._v("注解来声明一个函数需要被事务管理，通常我们单元测试为了保证每个测试之间的数据独立，会使用"),n("code",{pre:!0},[e._v("@Rollback")]),e._v("注解让每个单元测试都能在结束时回滚。而真正在开发业务逻辑时，我们通常在service层接口中使用"),n("code",{pre:!0},[e._v("@Transactional")]),e._v("来对各个业务逻辑进行事务管理的配置，例如：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("public interface UserService {\n    \n    @Transactional\n    User login(String name, String password);\n    \n}\n")])]),e._v(" "),n("h3",[e._v("事务详解")]),e._v(" "),n("p",[e._v("上面的例子中我们使用了默认的事务配置，可以满足一些基本的事务需求，但是当我们项目较大较复杂时（比如，有多个数据源等），这时候需要在声明事务时，指定不同的事务管理器。对于不同数据源的事务管理配置可以见"),n("a",{attrs:{href:"/Data/MoreDataConfig"}},[e._v("《Spring Boot多数据源配置与使用》")]),e._v("中的设置。在声明事务时，只需要通过value属性指定配置的事务管理器名即可，例如："),n("code",{pre:!0},[e._v('@Transactional(value="transactionManagerPrimary")')]),e._v("。")]),e._v(" "),n("p",[e._v("除了指定不同的事务管理器之后，还能对事务进行隔离级别和传播行为的控制，下面分别详细解释：")]),e._v(" "),n("p",[n("strong",[e._v("隔离级别")])]),e._v(" "),n("p",[e._v("隔离级别是指若干个并发的事务之间的隔离程度，与我们开发时候主要相关的场景包括：脏读取、重复读、幻读。")]),e._v(" "),n("p",[e._v("我们可以看"),n("code",{pre:!0},[e._v("org.springframework.transaction.annotation.Isolation")]),e._v("枚举类中定义了五个表示隔离级别的值：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("public enum Isolation {\n    DEFAULT(-1),\n    READ_UNCOMMITTED(1),\n    READ_COMMITTED(2),\n    REPEATABLE_READ(4),\n    SERIALIZABLE(8);\n}\n")])]),e._v(" "),n("ul",[n("li",[n("code",{pre:!0},[e._v("DEFAULT")]),e._v("：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是：READ_COMMITTED。")]),e._v(" "),n("li",[n("code",{pre:!0},[e._v("READ_UNCOMMITTED")]),e._v("：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读和不可重复读，因此很少使用该隔离级别。")]),e._v(" "),n("li",[n("code",{pre:!0},[e._v("READ_COMMITTED")]),e._v("：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。")]),e._v(" "),n("li",[n("code",{pre:!0},[e._v("REPEATABLE_READ")]),e._v("：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。该级别可以防止脏读和不可重复读。")]),e._v(" "),n("li",[n("code",{pre:!0},[e._v("SERIALIZABLE")]),e._v("：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。")])]),e._v(" "),n("p",[e._v("指定方法：通过使用"),n("code",{pre:!0},[e._v("isolation")]),e._v("属性设置，例如：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("@Transactional(isolation = Isolation.DEFAULT)\n")])]),e._v(" "),n("h3",[e._v("传播行为")]),e._v(" "),n("p",[e._v("所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。")]),e._v(" "),n("p",[e._v("我们可以看"),n("code",{pre:!0},[e._v("org.springframework.transaction.annotation.Propagation")]),e._v("枚举类中定义了6个表示传播行为的枚举值：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("public enum Propagation {\n    REQUIRED(0),\n    SUPPORTS(1),\n    MANDATORY(2),\n    REQUIRES_NEW(3),\n    NOT_SUPPORTED(4),\n    NEVER(5),\n    NESTED(6);\n}\n")])]),e._v(" "),n("ul",[n("li",[n("code",{pre:!0},[e._v("REQUIRED")]),e._v("：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。")]),e._v(" "),n("li",[n("code",{pre:!0},[e._v("SUPPORTS")]),e._v("：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。")]),e._v(" "),n("li",[n("code",{pre:!0},[e._v("MANDATORY")]),e._v("：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。")]),e._v(" "),n("li",[n("code",{pre:!0},[e._v("REQUIRES_NEW")]),e._v("：创建一个新的事务，如果当前存在事务，则把当前事务挂起。")]),e._v(" "),n("li",[n("code",{pre:!0},[e._v("NOT_SUPPORTED")]),e._v("：以非事务方式运行，如果当前存在事务，则把当前事务挂起。")]),e._v(" "),n("li",[n("code",{pre:!0},[e._v("NEVER")]),e._v("：以非事务方式运行，如果当前存在事务，则抛出异常。")]),e._v(" "),n("li",[n("code",{pre:!0},[e._v("NESTED")]),e._v("：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于"),n("code",{pre:!0},[e._v("REQUIRED")]),e._v("。")])]),e._v(" "),n("p",[e._v("指定方法：通过使用"),n("code",{pre:!0},[e._v("propagation")]),e._v("属性设置，例如：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("@Transactional(propagation = Propagation.REQUIRED)\n")])]),e._v(" "),n("p",[e._v("完整示例"),n("a",{attrs:{href:"Chapter3-3-1"}},[e._v("Chapter3-3-1")])])])}]},z={path:"/Data",cnName:"数据访问",component:L,name:"Data",children:[{name:"JdbcTemplate",path:"JdbcTemplate",cnName:"JdbcTemplate访问数据库",title:"Spring Boot中使用JdbcTemplate访问数据库",component:n("C7Lr")(null,D,!1,null,null,null).exports,date:"2018-11-13"},{name:"Jpa",path:"Jpa",cnName:"Spring-data-jpa使用",title:"Spring Boot中使用Spring-data-jpa让数据访问更简单、更优雅",component:n("C7Lr")(null,F,!1,null,null,null).exports,date:"2018-11-14"},{name:"MoreDataConfig",path:"MoreDataConfig",cnName:"多数据源配置",title:"Spring Boot多数据源配置与使用",component:n("C7Lr")(null,N,!1,null,null,null).exports,date:"2018-11-14"},{name:"Redis",path:"Redis",cnName:"使用NoSQL数据库（一）",title:"Spring Boot中使用Redis数据库",component:n("C7Lr")(null,O,!1,null,null,null).exports,date:"2018-11-14"},{name:"MongoDB",path:"MongoDB",cnName:"使用NoSQL数据库（二）",title:"Spring Boot中使用MongoDB数据库",component:n("C7Lr")(null,q,!1,null,null,null).exports,date:"2018-11-14"},{name:"MyBatis",path:"MyBatis",cnName:"整合MyBatis",title:"Spring Boot整合MyBatis",component:n("C7Lr")(null,J,!1,null,null,null).exports,date:"2018-11-14"},{name:"MyBatisConfig",path:"MyBatisConfig",cnName:"MyBatis注解配置详解",title:"Spring Boot中使用MyBatis注解配置详解",component:n("C7Lr")(null,H,!1,null,null,null).exports,date:"2018-11-14"},{name:"Flyway",path:"Flyway",cnName:"Flyway管理数据库版本",title:"Spring Boot中使用Flyway来管理数据库版本",component:n("C7Lr")(null,$,!1,null,null,null).exports,date:"2018-11-14"},{name:"LDAP",path:"LDAP",cnName:"LDAP统一管理用户信息",title:"Spring Boot中使用LDAP来统一管理用户信息",component:n("C7Lr")(null,W,!1,null,null,null).exports,date:"2018-11-14"},{name:"Transaction",path:"Transaction",cnName:"事务管理",title:"Spring Boot中的事务管理",component:n("C7Lr")(null,V,!1,null,null,null).exports,date:"2018-11-15"}]},G={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("section",[r("p",[e._v("首先，回顾并详细说明一下在"),r("a",{attrs:{href:"#/"}},[e._v("快速入门")]),e._v("中使用的"),r("code",{pre:!0},[e._v("@Controller")]),e._v("、"),r("code",{pre:!0},[e._v("@RestController")]),e._v("、"),r("code",{pre:!0},[e._v("@RequestMapping")]),e._v("注解。如果您对Spring MVC不熟悉并且还没有尝试过快速入门案例，建议先看一下"),r("a",{attrs:{href:"#/"}},[e._v("快速入门")]),e._v("的内容。")]),e._v(" "),r("ul",[r("li",[r("code",{pre:!0},[e._v("@Controller")]),e._v("：修饰class，用来创建处理http请求的对象")]),e._v(" "),r("li",[r("code",{pre:!0},[e._v("@RestController")]),e._v("：Spring4之后加入的注解，原来在"),r("code",{pre:!0},[e._v("@Controller")]),e._v("中返回json需要"),r("code",{pre:!0},[e._v("@ResponseBody")]),e._v("来配合，如果直接用"),r("code",{pre:!0},[e._v("@RestController")]),e._v("替代"),r("code",{pre:!0},[e._v("@Controller")]),e._v("就不需要再配置"),r("code",{pre:!0},[e._v("@ResponseBody")]),e._v("，默认返回json格式。")]),e._v(" "),r("li",[r("code",{pre:!0},[e._v("@RequestMapping")]),e._v("：配置url映射")])]),e._v(" "),r("p",[e._v("下面我们尝试使用Spring MVC来实现一组对User对象操作的RESTful API，配合注释详细说明在Spring MVC中如何映射HTTP请求、如何传参、如何编写单元测试。")]),e._v(" "),r("p",[r("strong",[e._v("RESTful API具体设计如下：")])]),e._v(" "),r("p",[r("img",{attrs:{src:n("yoQO"),alt:"RESTful API具体设计"}})]),e._v(" "),r("p",[e._v("User实体定义：")]),e._v(" "),r("pre",{pre:!0},[r("code",{attrs:{"v-pre":""}},[e._v("public class User { \n \n    private Long id; \n    private String name; \n    private Integer age; \n \n    // 省略setter和getter \n     \n}\n")])]),e._v(" "),r("p",[e._v("实现对User对象的操作接口")]),e._v(" "),r("pre",{pre:!0},[r("code",{attrs:{"v-pre":""}},[e._v('@RestController \n@RequestMapping(value="/users")     // 通过这里配置使下面的映射都在/users下 \npublic class UserController { \n \n    // 创建线程安全的Map \n    static Map<Long, User> users = Collections.synchronizedMap(new HashMap<Long, User>()); \n \n    @RequestMapping(value="/", method=RequestMethod.GET) \n    public List<User> getUserList() { \n        // 处理"/users/"的GET请求，用来获取用户列表 \n        // 还可以通过@RequestParam从页面中传递参数来进行查询条件或者翻页信息的传递 \n        List<User> r = new ArrayList<User>(users.values()); \n        return r; \n    } \n \n    @RequestMapping(value="/", method=RequestMethod.POST) \n    public String postUser(@ModelAttribute User user) { \n        // 处理"/users/"的POST请求，用来创建User \n        // 除了@ModelAttribute绑定参数之外，还可以通过@RequestParam从页面中传递参数 \n        users.put(user.getId(), user); \n        return "success"; \n    } \n \n    @RequestMapping(value="/{id}", method=RequestMethod.GET) \n    public User getUser(@PathVariable Long id) { \n        // 处理"/users/{id}"的GET请求，用来获取url中id值的User信息 \n        // url中的id可通过@PathVariable绑定到函数的参数中 \n        return users.get(id); \n    } \n \n    @RequestMapping(value="/{id}", method=RequestMethod.PUT) \n    public String putUser(@PathVariable Long id, @ModelAttribute User user) { \n        // 处理"/users/{id}"的PUT请求，用来更新User信息 \n        User u = users.get(id); \n        u.setName(user.getName()); \n        u.setAge(user.getAge()); \n        users.put(id, u); \n        return "success"; \n    } \n \n    @RequestMapping(value="/{id}", method=RequestMethod.DELETE) \n    public String deleteUser(@PathVariable Long id) { \n        // 处理"/users/{id}"的DELETE请求，用来删除User \n        users.remove(id); \n        return "success"; \n    } \n \n}\n')])]),e._v(" "),r("p",[e._v("下面针对该Controller编写测试用例验证正确性，具体如下。当然也可以通过浏览器插件等进行请求提交验证。")]),e._v(" "),r("pre",{pre:!0},[r("code",{attrs:{"v-pre":""}},[e._v('RunWith(SpringJUnit4ClassRunner.class) \n@SpringApplicationConfiguration(classes = MockServletContext.class) \n@WebAppConfiguration \npublic class ApplicationTests { \n \n\tprivate MockMvc mvc; \n \n\t@Before \n\tpublic void setUp() throws Exception { \n\t\tmvc = MockMvcBuilders.standaloneSetup(new UserController()).build(); \n\t} \n \n\t@Test \n\tpublic void testUserController() throws Exception { \n        // 测试UserController \n\t\tRequestBuilder request = null; \n \n\t\t// 1、get查一下user列表，应该为空 \n\t\trequest = get("/users/"); \n\t\tmvc.perform(request) \n\t\t\t\t.andExpect(status().isOk()) \n\t\t\t\t.andExpect(content().string(equalTo("[]"))); \n \n\t\t// 2、post提交一个user \n\t\trequest = post("/users/") \n\t\t\t\t.param("id", "1") \n\t\t\t\t.param("name", "测试大师") \n\t\t\t\t.param("age", "20"); \n\t\tmvc.perform(request) \n\t\t        .andExpect(content().string(equalTo("success"))); \n \n\t\t// 3、get获取user列表，应该有刚才插入的数据 \n\t\trequest = get("/users/"); \n\t\tmvc.perform(request) \n\t\t\t\t.andExpect(status().isOk()) \n\t\t\t\t.andExpect(content().string(equalTo("[{\\"id\\":1,\\"name\\":\\"测试大师\\",\\"age\\":20}]"))); \n \n\t\t// 4、put修改id为1的user \n\t\trequest = put("/users/1") \n\t\t\t\t.param("name", "测试终极大师") \n\t\t\t\t.param("age", "30"); \n\t\tmvc.perform(request) \n\t\t\t\t.andExpect(content().string(equalTo("success"))); \n \n\t\t// 5、get一个id为1的user \n\t\trequest = get("/users/1"); \n\t\tmvc.perform(request) \n\t\t\t\t.andExpect(content().string(equalTo("{\\"id\\":1,\\"name\\":\\"测试终极大师\\",\\"age\\":30}"))); \n \n\t\t// 6、del删除id为1的user \n\t\trequest = delete("/users/1"); \n\t\tmvc.perform(request) \n\t\t\t\t.andExpect(content().string(equalTo("success"))); \n \n\t\t// 7、get查一下user列表，应该为空 \n\t\trequest = get("/users/"); \n\t\tmvc.perform(request) \n\t\t\t\t.andExpect(status().isOk()) \n\t\t\t\t.andExpect(content().string(equalTo("[]"))); \n \n\t} \n \n}\n')])]),e._v(" "),r("p",[e._v("至此，我们通过引入web模块（没有做其他的任何配置），就可以轻松利用Spring MVC的功能，以非常简洁的代码完成了对User对象的RESTful API的创建以及单元测试的编写。其中同时介绍了Spring MVC中最为常用的几个核心注解："),r("code",{pre:!0},[e._v("@Controller")]),e._v(","),r("code",{pre:!0},[e._v("@RestController")]),e._v(","),r("code",{pre:!0},[e._v("RequestMapping")]),e._v("以及一些参数绑定的注解："),r("code",{pre:!0},[e._v("@PathVariable")]),e._v(","),r("code",{pre:!0},[e._v("@ModelAttribute")]),e._v(","),r("code",{pre:!0},[e._v("@RequestParam")]),e._v("等。")]),e._v(" "),r("p",[r("a",{attrs:{href:"http://git.oschina.net/didispace/SpringBoot-Learning"}},[e._v("Spring Boot教程完整案例")])])])}]},Q={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("blockquote",[n("p",[n("a",{attrs:{href:"#/"}},[e._v("Spring Boot")]),e._v("快速入门中我们完成了一个简单的RESTful Service，体验了快速开发的特性。在留言中也有朋友提到如何把处理结果渲染到页面上。那么本篇就在上篇基础上介绍一下如何进行Web应用的开发。")])]),e._v(" "),n("h2",[e._v("静态资源访问")]),e._v(" "),n("p",[e._v("在我们开发Web应用的时候，需要引用大量的js、css、图片等静态资源。")]),e._v(" "),n("h3",[e._v("默认配置")]),e._v(" "),n("p",[e._v("Spring Boot默认提供静态资源目录位置需置于classpath下，目录名需符合如下规则：")]),e._v(" "),n("ul",[n("li",[e._v("/static")]),e._v(" "),n("li",[e._v("/public")]),e._v(" "),n("li",[e._v("/resources")]),e._v(" "),n("li",[e._v("/META-INF/resources")])]),e._v(" "),n("p",[e._v("举例：我们可以在"),n("code",{pre:!0},[e._v("src/main/resources/")]),e._v("目录下创建"),n("code",{pre:!0},[e._v("static")]),e._v("，在该位置放置一个图片文件。启动程序后，尝试访问"),n("code",{pre:!0},[e._v("http://localhost:8080/D.jpg")]),e._v("。如能显示图片，配置成功。")]),e._v(" "),n("h2",[e._v("渲染Web页面")]),e._v(" "),n("p",[e._v("在之前的示例中，我们都是通过@RestController来处理请求，所以返回的内容为json对象。那么如果需要渲染html页面的时候，要如何实现呢？")]),e._v(" "),n("h3",[e._v("模板引擎")]),e._v(" "),n("p",[e._v("在动态HTML实现上Spring Boot依然可以完美胜任，并且提供了多种模板引擎的默认配置支持，所以在推荐的模板引擎下，我们可以很快的上手开发动态网站。")]),e._v(" "),n("p",[e._v("Spring Boot提供了默认配置的模板引擎主要有以下几种：")]),e._v(" "),n("ul",[n("li",[e._v("Thymeleaf")]),e._v(" "),n("li",[e._v("FreeMarker")]),e._v(" "),n("li",[e._v("Velocity")]),e._v(" "),n("li",[e._v("Groovy")]),e._v(" "),n("li",[e._v("Mustache")])]),e._v(" "),n("p",[n("strong",[e._v("Spring Boot建议使用这些模板引擎，避免使用JSP，若一定要使用JSP将无法实现Spring Boot的多种特性，具体可见后文：支持JSP的配置")])]),e._v(" "),n("p",[e._v("当你使用上述模板引擎中的任何一个，它们默认的模板配置路径为："),n("code",{pre:!0},[e._v("src/main/resources/templates")]),e._v("。当然也可以修改这个路径，具体如何修改，可在后续各模板引擎的配置属性中查询并修改。")]),e._v(" "),n("h3",[e._v("Thymeleaf")]),e._v(" "),n("p",[e._v("Thymeleaf是一个XML/XHTML/HTML5模板引擎，可用于Web与非Web环境中的应用开发。它是一个开源的Java库，基于Apache License 2.0许可，由Daniel Fernández创建，该作者还是Java加密库Jasypt的作者。")]),e._v(" "),n("p",[e._v("Thymeleaf提供了一个用于整合Spring MVC的可选模块，在应用开发中，你可以使用Thymeleaf来完全代替JSP或其他模板引擎，如Velocity、FreeMarker等。Thymeleaf的主要目标在于提供一种可被浏览器正确显示的、格式良好的模板创建方式，因此也可以用作静态建模。你可以使用它创建经过验证的XML与HTML模板。相对于编写逻辑或代码，开发者只需将标签属性添加到模板中即可。接下来，这些标签属性就会在DOM（文档对象模型）上执行预先制定好的逻辑。")]),e._v(" "),n("p",[e._v("示例模板：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('<table>\n  <thead>\n    <tr>\n      <th th:text="#{msgs.headers.name}">Name</td>\n      <th th:text="#{msgs.headers.price}">Price</td>\n    </tr>\n  </thead>\n  <tbody>\n    <tr th:each="prod : ${allProducts}">\n      <td th:text="${prod.name}">Oranges</td>\n      <td th:text="${#numbers.formatDecimal(prod.price,1,2)}">0.99</td>\n    </tr>\n  </tbody>\n</table>\n')])]),e._v(" "),n("p",[e._v("可以看到Thymeleaf主要以属性的方式加入到html标签中，浏览器在解析html时，当检查到没有的属性时候会忽略，所以Thymeleaf的模板可以通过浏览器直接打开展现，这样非常有利于前后端的分离。")]),e._v(" "),n("p",[e._v("在Spring Boot中使用Thymeleaf，只需要引入下面依赖，并在默认的模板路径"),n("code",{pre:!0},[e._v("src/main/resources/templates")]),e._v("下编写模板文件即可完成。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-thymeleaf</artifactId>\n</dependency>\n")])]),e._v(" "),n("p",[e._v("在完成配置之后，举一个简单的例子，在快速入门工程的基础上，举一个简单的示例来通过Thymeleaf渲染一个页面。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@Controller\npublic class HelloController {\n\n    @RequestMapping("/")\n    public String index(ModelMap map) {\n        // 加入一个属性，用来在模板中读取\n        map.addAttribute("host", "http://blog.didispace.com");\n        // return模板文件的名称，对应src/main/resources/templates/index.html\n        return "index";  \n    }\n\n}\n')])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('<!DOCTYPE html>\n<html>\n<head lang="en">\n    <meta charset="UTF-8" />\n    <title></title>\n</head>\n<body>\n<h1 th:text="${host}">Hello World</h1>\n</body>\n</html>\n')])]),e._v(" "),n("p",[e._v("如上页面，直接打开html页面展现Hello World，但是启动程序后，访问"),n("code",{pre:!0},[e._v("http://localhost:8080/")]),e._v("，则是展示Controller中host的值："),n("code",{pre:!0},[e._v("http://blog.didispace.com")]),e._v("，做到了不破坏HTML自身内容的数据逻辑分离。")]),e._v(" "),n("p",[e._v("更多Thymeleaf的页面语法，还请访问Thymeleaf的官方文档查询使用。")]),e._v(" "),n("p",[n("strong",[e._v("Thymeleaf的默认参数配置")])]),e._v(" "),n("p",[e._v("如有需要修改默认配置的时候，只需复制下面要修改的属性到"),n("code",{pre:!0},[e._v("application.properties中")]),e._v("，并修改成需要的值，如修改模板文件的扩展名，修改默认的模板路径等。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("# Enable template caching.\nspring.thymeleaf.cache=true \n# Check that the templates location exists.\nspring.thymeleaf.check-template-location=true \n# Content-Type value.\nspring.thymeleaf.content-type=text/html \n# Enable MVC Thymeleaf view resolution.\nspring.thymeleaf.enabled=true \n# Template encoding.\nspring.thymeleaf.encoding=UTF-8 \n# Comma-separated list of view names that should be excluded from resolution.\nspring.thymeleaf.excluded-view-names= \n# Template mode to be applied to templates. See also StandardTemplateModeHandlers.\nspring.thymeleaf.mode=HTML5 \n# Prefix that gets prepended to view names when building a URL.\nspring.thymeleaf.prefix=classpath:/templates/ \n# Suffix that gets appended to view names when building a URL.\nspring.thymeleaf.suffix=.html  spring.thymeleaf.template-resolver-order= # Order of the template resolver in the chain. spring.thymeleaf.view-names= # Comma-separated list of view names that can be resolved.\n")])]),e._v(" "),n("h3",[e._v("支持JSP的配置")]),e._v(" "),n("p",[e._v("Spring Boot并不建议使用，但如果一定要使用，可以参考此工程作为脚手架："),n("a",{attrs:{href:"https://github.com/spring-projects/spring-boot/tree/v1.3.2.RELEASE/spring-boot-samples/spring-boot-sample-web-jsp"}},[e._v("JSP支持")])]),e._v(" "),n("p",[n("a",{attrs:{href:"http://git.oschina.net/didispace/SpringBoot-Learning"}},[e._v("Spring Boot教程完整案例")])])])}]},X={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("section",[r("p",[e._v("由于Spring Boot能够快速开发、便捷部署等特性，相信有很大一部分Spring Boot的用户会用来构建RESTful API。而我们构建RESTful API的目的通常都是由于多终端的原因，这些终端会共用很多底层业务逻辑，因此我们会抽象出这样一层来同时服务于多个移动端或者Web前端。")]),e._v(" "),r("p",[e._v("这样一来，我们的RESTful API就有可能要面对多个开发人员或多个开发团队：IOS开发、Android开发或是Web开发等。为了减少与其他团队平时开发期间的频繁沟通成本，传统做法我们会创建一份RESTful API文档来记录所有接口细节，然而这样的做法有以下几个问题：")]),e._v(" "),r("ul",[r("li",[e._v("由于接口众多，并且细节复杂（需要考虑不同的HTTP请求类型、HTTP头部信息、HTTP请求内容等），高质量地创建这份文档本身就是件非常吃力的事，下游的抱怨声不绝于耳。")]),e._v(" "),r("li",[e._v("随着时间推移，不断修改接口实现的时候都必须同步修改接口文档，而文档与代码又处于两个不同的媒介，除非有严格的管理机制，不然很容易导致不一致现象。")])]),e._v(" "),r("p",[e._v("为了解决上面这样的问题，本文将介绍RESTful API的重磅好伙伴Swagger2，它可以轻松的整合到Spring Boot中，并与Spring MVC程序配合组织出强大RESTful API文档。它既可以减少我们创建文档的工作量，同时说明内容又整合入实现代码中，让维护文档和修改代码整合为一体，可以让我们在修改代码逻辑的同时方便的修改文档说明。另外Swagger2也提供了强大的页面测试功能来调试每个RESTful API。具体效果如下图所示：")]),e._v(" "),r("p",[r("img",{attrs:{src:n("Yqqd"),alt:"Swagger2"}})]),e._v(" "),r("p",[e._v("下面来具体介绍，如果在Spring Boot中使用Swagger2。首先，我们需要一个Spring Boot实现的RESTful API工程，若您没有做过这类内容，建议先阅读\n"),r("a",{attrs:{href:"/Web/RESTfulAPI"}},[e._v("Spring Boot构建一个较为复杂的RESTful APIs和单元测试")]),e._v("。")]),e._v(" "),r("p",[e._v("下面的内容我们会以"),r("a",{attrs:{href:"https://gitee.com/didispace/SpringBoot-Learning"}},[e._v("教程样例中")]),e._v("的Chapter3-1-1进行下面的实验（Chpater3-1-5是我们的结果工程，亦可参考）。")]),e._v(" "),r("h3",[e._v("添加Swagger2依赖")]),e._v(" "),r("p",[e._v("在"),r("code",{pre:!0},[e._v("pom.xml")]),e._v("中加入Swagger2的依赖")]),e._v(" "),r("pre",{pre:!0},[r("code",{attrs:{"v-pre":""}},[e._v("<dependency>\n    <groupId>io.springfox</groupId>\n    <artifactId>springfox-swagger2</artifactId>\n    <version>2.2.2</version>\n</dependency>\n<dependency>\n    <groupId>io.springfox</groupId>\n    <artifactId>springfox-swagger-ui</artifactId>\n    <version>2.2.2</version>\n</dependency>\n")])]),e._v(" "),r("h3",[e._v("创建Swagger2配置类")]),e._v(" "),r("p",[e._v("在"),r("code",{pre:!0},[e._v("Application.java")]),e._v("同级创建Swagger2的配置类"),r("code",{pre:!0},[e._v("Swagger2")]),e._v("。")]),e._v(" "),r("pre",{pre:!0},[r("code",{attrs:{"v-pre":""}},[e._v('@Configuration\n@EnableSwagger2\npublic class Swagger2 {\n\n    @Bean\n    public Docket createRestApi() {\n        return new Docket(DocumentationType.SWAGGER_2)\n                .apiInfo(apiInfo())\n                .select()\n                .apis(RequestHandlerSelectors.basePackage("com.didispace.web"))\n                .paths(PathSelectors.any())\n                .build();\n    }\n\n    private ApiInfo apiInfo() {\n        return new ApiInfoBuilder()\n                .title("Spring Boot中使用Swagger2构建RESTful APIs")\n                .description("更多Spring Boot相关文章请关注：http://blog.didispace.com/")\n                .termsOfServiceUrl("http://blog.didispace.com/")\n                .contact("程序猿DD")\n                .version("1.0")\n                .build();\n    }\n\n}\n')])]),e._v(" "),r("p",[e._v("如上代码所示，通过"),r("code",{pre:!0},[e._v("@Configuration")]),e._v("注解，让Spring来加载该类配置。再通过"),r("code",{pre:!0},[e._v("@EnableSwagger2")]),e._v("注解来启用Swagger2。")]),e._v(" "),r("p",[e._v("再通过"),r("code",{pre:!0},[e._v("createRestApi")]),e._v("函数创建"),r("code",{pre:!0},[e._v("Docket")]),e._v("的Bean之后，"),r("code",{pre:!0},[e._v("apiInfo()")]),e._v("用来创建该Api的基本信息（这些基本信息会展现在文档页面中）。"),r("code",{pre:!0},[e._v("select()")]),e._v("函数返回一个"),r("code",{pre:!0},[e._v("ApiSelectorBuilder")]),e._v("实例用来控制哪些接口暴露给Swagger来展现，本例采用指定扫描的包路径来定义，Swagger会扫描该包下所有Controller定义的API，并产生文档内容（除了被"),r("code",{pre:!0},[e._v("@ApiIgnore")]),e._v("指定的请求）。")]),e._v(" "),r("h3",[e._v("添加文档内容")]),e._v(" "),r("p",[e._v("在完成了上述配置后，其实已经可以生产文档内容，但是这样的文档主要针对请求本身，而描述主要来源于函数等命名产生，对用户并不友好，我们通常需要自己增加一些说明来丰富文档内容。如下所示，我们通过"),r("code",{pre:!0},[e._v("@ApiOperation")]),e._v("注解来给API增加说明、通过"),r("code",{pre:!0},[e._v("@ApiImplicitParams")]),e._v("、"),r("code",{pre:!0},[e._v("@ApiImplicitParam")]),e._v("注解来给参数增加说明。")]),e._v(" "),r("pre",{pre:!0},[r("code",{attrs:{"v-pre":""}},[e._v('@RestController\n@RequestMapping(value="/users")     // 通过这里配置使下面的映射都在/users下，可去除\npublic class UserController {\n\n    static Map<Long, User> users = Collections.synchronizedMap(new HashMap<Long, User>());\n\n    @ApiOperation(value="获取用户列表", notes="")\n    @RequestMapping(value={""}, method=RequestMethod.GET)\n    public List<User> getUserList() {\n        List<User> r = new ArrayList<User>(users.values());\n        return r;\n    }\n\n    @ApiOperation(value="创建用户", notes="根据User对象创建用户")\n    @ApiImplicitParam(name = "user", value = "用户详细实体user", required = true, dataType = "User")\n    @RequestMapping(value="", method=RequestMethod.POST)\n    public String postUser(@RequestBody User user) {\n        users.put(user.getId(), user);\n        return "success";\n    }\n\n    @ApiOperation(value="获取用户详细信息", notes="根据url的id来获取用户详细信息")\n    @ApiImplicitParam(name = "id", value = "用户ID", required = true, dataType = "Long")\n    @RequestMapping(value="/{id}", method=RequestMethod.GET)\n    public User getUser(@PathVariable Long id) {\n        return users.get(id);\n    }\n\n    @ApiOperation(value="更新用户详细信息", notes="根据url的id来指定更新对象，并根据传过来的user信息来更新用户详细信息")\n    @ApiImplicitParams({\n            @ApiImplicitParam(name = "id", value = "用户ID", required = true, dataType = "Long"),\n            @ApiImplicitParam(name = "user", value = "用户详细实体user", required = true, dataType = "User")\n    })\n    @RequestMapping(value="/{id}", method=RequestMethod.PUT)\n    public String putUser(@PathVariable Long id, @RequestBody User user) {\n        User u = users.get(id);\n        u.setName(user.getName());\n        u.setAge(user.getAge());\n        users.put(id, u);\n        return "success";\n    }\n\n    @ApiOperation(value="删除用户", notes="根据url的id来指定删除对象")\n    @ApiImplicitParam(name = "id", value = "用户ID", required = true, dataType = "Long")\n    @RequestMapping(value="/{id}", method=RequestMethod.DELETE)\n    public String deleteUser(@PathVariable Long id) {\n        users.remove(id);\n        return "success";\n    }\n\n}\n')])]),e._v(" "),r("p",[e._v("完成上述代码添加上，启动Spring Boot程序，访问："),r("a",{attrs:{href:"http://localhost:8080/swagger-ui.html"}},[e._v("http://localhost:8080/swagger-ui.html")]),e._v("\n。就能看到前文所展示的RESTful API的页面。我们可以再点开具体的API请求，以POST类型的/users请求为例，可找到上述代码中我们配置的Notes信息以及参数user的描述信息，如下图所示。")]),e._v(" "),r("p",[r("img",{attrs:{src:n("JG8F"),alt:"swagger2"}})]),e._v(" "),r("h3",[e._v("API文档访问与调试")]),e._v(" "),r("p",[e._v("在上图请求的页面中，我们看到user的Value是个输入框？是的，Swagger除了查看接口功能外，还提供了调试测试功能，我们可以点击上图中右侧的Model Schema（黄色区域：它指明了User的数据结构），此时Value中就有了user对象的模板，我们只需要稍适修改，点击下方"),r("code",{pre:!0},[e._v("“Try it out！”")]),e._v("按钮，即可完成了一次请求调用！")]),e._v(" "),r("p",[e._v("此时，你也可以通过几个GET请求来验证之前的POST请求是否正确。")]),e._v(" "),r("p",[e._v("相比为这些接口编写文档的工作，我们增加的配置内容是非常少而且精简的，对于原有代码的侵入也在忍受范围之内。因此，在构建RESTful API的同时，加入swagger来对API文档进行管理，是个不错的选择。")]),e._v(" "),r("p",[e._v("完整结果示例可查看"),r("a",{attrs:{href:"Chapter3-1-5"}},[e._v("Chapter3-1-5")]),e._v("。")]),e._v(" "),r("h3",[e._v("参考信息")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"http://swagger.io/"}},[e._v("Swagger官方网站")])])])])}]},Y={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("section",[r("p",[e._v("我们在做Web应用的时候，请求处理过程中发生错误是非常常见的情况。Spring Boot提供了一个默认的映射："),r("code",{pre:!0},[e._v("/error")]),e._v("，当处理中抛出异常之后，会转到该请求中处理，并且该请求有一个全局的错误页面用来展示异常内容。")]),e._v(" "),r("p",[e._v("选择一个之前实现过的Web应用（"),r("a",{attrs:{href:"Chapter3-1-2"}},[e._v("Chapter3-1-2")]),e._v("）为基础，启动该应用，访问一个不存在的URL，或是修改处理内容，直接抛出异常，如：")]),e._v(" "),r("pre",{pre:!0},[r("code",{attrs:{"v-pre":""}},[e._v('@RequestMapping("/hello")\npublic String hello() throws Exception {\n    throw new Exception("发生错误");\n}\n')])]),e._v(" "),r("p",[e._v("此时，可以看到类似下面的报错页面，该页面就是Spring Boot提供的默认error映射页面。")]),e._v(" "),r("p",[r("img",{attrs:{src:n("knyi"),alt:"Abnormity"}})]),e._v(" "),r("h2",[e._v("统一异常处理")]),e._v(" "),r("p",[e._v("虽然，Spring Boot中实现了默认的error映射，但是在实际应用中，上面你的错误页面对用户来说并不够友好，我们通常需要去实现我们自己的异常提示。")]),e._v(" "),r("p",[e._v("下面我们以之前的Web应用例子为基础（"),r("a",{attrs:{href:"Chapter3-1-2"}},[e._v("Chapter3-1-2")]),e._v("），进行统一异常处理的改造。")]),e._v(" "),r("ul",[r("li",[e._v("创建全局异常处理类：通过使用"),r("code",{pre:!0},[e._v("@ControllerAdvice")]),e._v("定义统一的异常处理类，而不是在每个Controller中逐个定义。"),r("code",{pre:!0},[e._v("@ExceptionHandler")]),e._v("用来定义函数针对的异常类型，最后将Exception对象和请求URL映射到"),r("code",{pre:!0},[e._v("error.html")]),e._v("中")])]),e._v(" "),r("pre",{pre:!0},[r("code",{attrs:{"v-pre":""}},[e._v('@ControllerAdvice\nclass GlobalExceptionHandler {\n\n    public static final String DEFAULT_ERROR_VIEW = "error";\n\n    @ExceptionHandler(value = Exception.class)\n    public ModelAndView defaultErrorHandler(HttpServletRequest req, Exception e) throws Exception {\n        ModelAndView mav = new ModelAndView();\n        mav.addObject("exception", e);\n        mav.addObject("url", req.getRequestURL());\n        mav.setViewName(DEFAULT_ERROR_VIEW);\n        return mav;\n    }\n\n}\n')])]),e._v(" "),r("ul",[r("li",[e._v("实现"),r("code",{pre:!0},[e._v("error.html")]),e._v("页面展示：在"),r("code",{pre:!0},[e._v("templates")]),e._v("目录下创建"),r("code",{pre:!0},[e._v("error.html")]),e._v("，将请求的URL和Exception对象的message输出。")])]),e._v(" "),r("pre",{pre:!0},[r("code",{attrs:{"v-pre":""}},[e._v('<!DOCTYPE html>\n<html>\n<head lang="en">\n    <meta charset="UTF-8" />\n    <title>统一异常处理</title>\n</head>\n<body>\n    <h1>Error Handler</h1>\n    <div th:text="${url}"></div>\n    <div th:text="${exception.message}"></div>\n</body>\n</html>\n')])]),e._v(" "),r("p",[e._v("启动该应用，访问："),r("code",{pre:!0},[e._v("http://localhost:8080/hello")]),e._v("，可以看到如下错误提示页面。")]),e._v(" "),r("p",[e._v("![Error Handler.png](../../assets/Error Handler.png)")]),e._v(" "),r("p",[e._v("通过实现上述内容之后，我们只需要在"),r("code",{pre:!0},[e._v("Controller")]),e._v("中抛出"),r("code",{pre:!0},[e._v("Exception")]),e._v("，当然我们可能会有多种不同的"),r("code",{pre:!0},[e._v("Exception")]),e._v("。然后在"),r("code",{pre:!0},[e._v("@ControllerAdvice")]),e._v("类中，根据抛出的具体"),r("code",{pre:!0},[e._v("Exception")]),e._v("类型匹配"),r("code",{pre:!0},[e._v("@ExceptionHandler")]),e._v("中配置的异常类型来匹配错误映射和处理。")]),e._v(" "),r("h2",[e._v("返回JSON格式")]),e._v(" "),r("p",[e._v("在上述例子中，通过"),r("code",{pre:!0},[e._v("@ControllerAdvice")]),e._v("统一定义不同Exception映射到不同错误处理页面。而当我们要实现RESTful API时，返回的错误是JSON格式的数据，而不是HTML页面，这时候我们也能轻松支持。")]),e._v(" "),r("p",[e._v("本质上，只需在"),r("code",{pre:!0},[e._v("@ExceptionHandler")]),e._v("之后加入"),r("code",{pre:!0},[e._v("@ResponseBody")]),e._v("，就能让处理函数return的内容转换为JSON格式。")]),e._v(" "),r("p",[e._v("下面以一个具体示例来实现返回JSON格式的异常处理。")]),e._v(" "),r("ul",[r("li",[e._v("创建统一的JSON返回对象，code：消息类型，message：消息内容，url：请求的url，data：请求返回的数据")])]),e._v(" "),r("pre",{pre:!0},[r("code",{attrs:{"v-pre":""}},[e._v("public class ErrorInfo<T> {\n\n    public static final Integer OK = 0;\n    public static final Integer ERROR = 100;\n\n    private Integer code;\n    private String message;\n    private String url;\n    private T data;\n\n    // 省略getter和setter\n\n}\n")])]),e._v(" "),r("ul",[r("li",[e._v("创建一个自定义异常，用来实验捕获该异常，并返回json")])]),e._v(" "),r("pre",{pre:!0},[r("code",{attrs:{"v-pre":""}},[e._v("public class MyException extends Exception {\n\n    public MyException(String message) {\n        super(message);\n    }\n    \n}\n")])]),e._v(" "),r("ul",[r("li",[r("code",{pre:!0},[e._v("Controller")]),e._v("中增加json映射，抛出"),r("code",{pre:!0},[e._v("MyException")]),e._v("异常")])]),e._v(" "),r("pre",{pre:!0},[r("code",{attrs:{"v-pre":""}},[e._v('@Controller\npublic class HelloController {\n\n    @RequestMapping("/json")\n    public String json() throws MyException {\n        throw new MyException("发生错误2");\n    }\n\n}\n')])]),e._v(" "),r("p",[e._v("为"),r("code",{pre:!0},[e._v("MyException")]),e._v("异常创建对应的处理")]),e._v(" "),r("pre",{pre:!0},[r("code",{attrs:{"v-pre":""}},[e._v('@ControllerAdvice\npublic class GlobalExceptionHandler {\n\n    @ExceptionHandler(value = MyException.class)\n    @ResponseBody\n    public ErrorInfo<String> jsonErrorHandler(HttpServletRequest req, MyException e) throws Exception {\n        ErrorInfo<String> r = new ErrorInfo<>();\n        r.setMessage(e.getMessage());\n        r.setCode(ErrorInfo.ERROR);\n        r.setData("Some Data");\n        r.setUrl(req.getRequestURL().toString());\n        return r;\n    }\n\n}\n')])]),e._v(" "),r("ul",[r("li",[e._v("启动应用，访问："),r("a",{attrs:{href:"http://localhost:8080/json"}},[e._v("http://localhost:8080/json")]),e._v("，可以得到如下返回内容：")])]),e._v(" "),r("pre",{pre:!0},[r("code",{attrs:{"v-pre":""}},[e._v('{\n    code: 100，\n    data: "Some Data"，\n    message: "发生错误2"，\n    url: "http://localhost:8080/json"\n}\n')])]),e._v(" "),r("p",[e._v("至此，已完成在Spring Boot中创建统一的异常处理，实际实现还是依靠Spring MVC的注解，更多更深入的使用可参考Spring MVC的文档。")]),e._v(" "),r("p",[e._v("本文完整示例："),r("a",{attrs:{href:"chapter3-1-6"}},[e._v("chapter3-1-6")])])])}]},K={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("blockquote",[n("p",[n("code",{pre:!0},[e._v("LocalDate")]),e._v("、"),n("code",{pre:!0},[e._v("LocalTime")]),e._v("、"),n("code",{pre:!0},[e._v("LocalDateTime")]),e._v("是Java 8开始提供的时间日期API，主要用来优化Java 8以前对于时间日期的处理操作。然而，我们在使用Spring Boot或使用Spring Cloud Feign的时候，往往会发现使用请求参数或返回结果中有"),n("code",{pre:!0},[e._v("LocalDate")]),e._v("、"),n("code",{pre:!0},[e._v("LocalTime")]),e._v("、"),n("code",{pre:!0},[e._v("LocalDateTime")]),e._v("的时候会发生各种问题。本文我们就来说说这种情况下出现的问题，以及如何解决。")])]),e._v(" "),n("h3",[e._v("问题现象")]),e._v(" "),n("p",[e._v("先来看看症状。比如下面的例子：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@SpringBootApplication\npublic class Application {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n\n    @RestController\n    class HelloController {\n\n        @PostMapping("/user")\n        public UserDto user(@RequestBody UserDto userDto) throws Exception {\n            return userDto;\n        }\n\n    }\n\n    @Data\n    @NoArgsConstructor\n    @AllArgsConstructor\n    static class UserDto {\n\n        private String userName;\n        private LocalDate birthday;\n\n    }\n\n}\n')])]),e._v(" "),n("p",[e._v("上面的代码构建了一个简单的Spring Boot Web应用，它提供了一个提交用户信息的接口，用户信息中包含了"),n("code",{pre:!0},[e._v("LocalDate")]),e._v("类型的数据。此时，如果我们使用Feign来调用这个接口的时候，会得到如下错误：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('2018-03-13 09:22:58,445 WARN  [http-nio-9988-exec-3] org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver - Failed to read HTTP message: org.springframework.http.converter.HttpMessageNotReadableException: JSON parse error: Can not construct instance of java.time.LocalDate: no suitable constructor found, can not deserialize from Object value (missing default constructor or creator, or perhaps need to add/enable type information?); nested exception is com.fasterxml.jackson.databind.JsonMappingException: Can not construct instance of java.time.LocalDate: no suitable constructor found, can not deserialize from Object value (missing default constructor or creator, or perhaps need to add/enable type information?)\n at [Source: java.io.PushbackInputStream@67064c65; line: 1, column: 63] (through reference chain: java.util.ArrayList[0]->com.didispace.UserDto["birthday"])\n')])]),e._v(" "),n("h3",[e._v("分析解决")]),e._v(" "),n("p",[e._v("对于上面的错误信息"),n("code",{pre:!0},[e._v("JSON parse error: Can not construct instance of java.time.LocalDate: no suitable constructor found, can not deserialize from Object value")]),e._v("，熟悉Spring MVC的童鞋应该马上就能定位错误与"),n("code",{pre:!0},[e._v("LocalDate")]),e._v("的反序列化有关。但是，依然会有很多读者会被这段错误信息"),n("code",{pre:!0},[e._v('java.util.ArrayList[0]->com.didispace.UserDto["birthday"]')]),e._v("所困惑。我们命名提交的"),n("code",{pre:!0},[e._v('UserDto["birthday"]')]),e._v("是个"),n("code",{pre:!0},[e._v("LocalDate")]),e._v("对象嘛，跟"),n("code",{pre:!0},[e._v("ArrayList")]),e._v("列表对象有啥关系呢？")]),e._v(" "),n("p",[e._v("我们不妨通过postman等手工发一个请求看看服务端返回的是什么？比如你可以按下图发起一个请求：")]),e._v(" "),n("p",[e._v("!(Spring-Boot-And-Feign-Use-localdate-1.png)[../../assets/Spring-Boot-And-Feign-Use-localdate-1.png]")]),e._v(" "),n("p",[e._v("从上图中我们就可以理解上面我所提到的困惑了，实际上默认情况下Spring MVC对于LocalDate序列化成了一个数组类型，而Feign在调用的时候，还是按照ArrayList来处理，所以自然无法反序列化为"),n("code",{pre:!0},[e._v("LocalDate")]),e._v("对象了。")]),e._v(" "),n("p",[n("strong",[e._v("解决方法")])]),e._v(" "),n("p",[e._v("为了解决上面的问题非常简单，因为jackson也为此提供了一整套的序列化方案，我们只需要在"),n("code",{pre:!0},[e._v("pom.xml")]),e._v("中引入"),n("code",{pre:!0},[e._v("jackson-datatype-jsr310")]),e._v("依赖，具体如下：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("<dependency>\n    <groupId>com.fasterxml.jackson.datatype</groupId>\n    <artifactId>jackson-datatype-jsr310</artifactId>\n</dependency>\n")])]),e._v(" "),n("p",[n("em",[e._v("注意：在设置了spring boot的parent的情况下不需要指定具体的版本，也不建议指定某个具体版本")])]),e._v(" "),n("p",[e._v("在该模块中封装对Java 8的时间日期API序列化的实现，其具体实现在这个类中："),n("code",{pre:!0},[e._v("com.fasterxml.jackson.datatype.jsr310.JavaTimeModule")]),e._v("（注意：一些较早版本疯转在这个类中“"),n("code",{pre:!0},[e._v("com.fasterxml.jackson.datatype.jsr310.JSR310Module")]),e._v("）。在配置了依赖之后，我们只需要在上面的应用主类中增加这个序列化模块，并禁用对日期以时间戳方式输出的特性：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("@Bean\npublic ObjectMapper serializingObjectMapper() {\n    ObjectMapper objectMapper = new ObjectMapper();\n    objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n    objectMapper.registerModule(new JavaTimeModule());\n    return objectMapper;\n}\n")])]),e._v(" "),n("p",[e._v("此时，我们在访问刚才的接口，就不再是数组类型了，同时对于Feign客户端的调用也不会再出现上面的错误了。")]),e._v(" "),n("h3",[e._v("代码示例")]),e._v(" "),n("p",[e._v("本文的相关例子可以查看下面仓库中的"),n("code",{pre:!0},[e._v("Chapter3-1-7")]),e._v("目录：")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"Github%EF%BC%9Ahttps://github.com/dyc87112/SpringBoot-Learning"}},[e._v("Github：https://github.com/dyc87112/SpringBoot-Learning")])])])])}]},Z={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("section",[r("p",[e._v("在之前的所有Spring Boot教程中，我们都只提到和用到了针对HTML和JSON格式的请求与响应处理。那么对于XML格式的请求要如何快速的在Controller中包装成对象，以及如何以XML的格式返回一个对象呢？")]),e._v(" "),r("h2",[e._v("实现原理：消息转换器（Message Converter）")]),e._v(" "),r("p",[e._v("在扩展上述问题之前，我们先要知道Spring Boot中处理HTTP请求的实现是采用的Spring MVC。而在Spring MVC中有一个消息转换器这个概念，它主要负责处理各种不同格式的请求数据进行处理，并包转换成对象，以提供更好的编程体验。")]),e._v(" "),r("p",[e._v("在Spring MVC中定义了"),r("code",{pre:!0},[e._v("HttpMessageConverter")]),e._v("接口，抽象了消息转换器对类型的判断、对读写的判断与操作，具体可见如下定义：")]),e._v(" "),r("pre",{pre:!0},[r("code",{attrs:{"v-pre":""}},[e._v("public interface HttpMessageConverter<T> {\n\n    boolean canRead(Class<?> clazz, @Nullable MediaType mediaType);\n\n    boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType);\n\n    List<MediaType> getSupportedMediaTypes();\n\n    T read(Class<? extends T> clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException;\n\n    void write(T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException;\n\n}\n")])]),e._v(" "),r("p",[e._v("众所周知，HTTP请求的Content-Type有各种不同格式定义，如果要支持Xml格式的消息转换，就必须要使用对应的转换器。Spring MVC中默认已经有一套采用Jackson实现的转换器"),r("code",{pre:!0},[e._v("MappingJackson2XmlHttpMessageConverter")]),e._v("。")]),e._v(" "),r("h2",[e._v("扩展实现")]),e._v(" "),r("p",[r("strong",[e._v("第一步：引入Xml消息转换器")])]),e._v(" "),r("p",[e._v("在传统Spring应用中，我们可以通过如下配置加入对Xml格式数据的消息转换实现：")]),e._v(" "),r("pre",{pre:!0},[r("code",{attrs:{"v-pre":""}},[e._v("@Configuration\npublic class MessageConverterConfig1 extends WebMvcConfigurerAdapter {\n    @Override\n    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n        Jackson2ObjectMapperBuilder builder = Jackson2ObjectMapperBuilder.xml();\n        builder.indentOutput(true);\n        converters.add(new MappingJackson2XmlHttpMessageConverter(builder.build()));\n    }\n}\n")])]),e._v(" "),r("p",[e._v("在Spring Boot应用不用像上面这么麻烦，只需要加入"),r("code",{pre:!0},[e._v("jackson-dataformat-xml")]),e._v("依赖，Spring Boot就会自动引入"),r("code",{pre:!0},[e._v("MappingJackson2XmlHttpMessageConverter")]),e._v("的实现：")]),e._v(" "),r("pre",{pre:!0},[r("code",{attrs:{"v-pre":""}},[e._v("<dependency>\n    <groupId>com.fasterxml.jackson.dataformat</groupId>\n    <artifactId>jackson-dataformat-xml</artifactId>\n</dependency>\n")])]),e._v(" "),r("p",[e._v("同时，为了配置Xml数据与维护对象属性的关系所要使用的注解也在上述依赖中，所以这个依赖也是必须的。")]),e._v(" "),r("p",[r("strong",[e._v("第二步：定义对象与Xml的关系")])]),e._v(" "),r("p",[e._v("做好了基础扩展之后，下面就可以定义Xml内容对应的Java对象了，比如：")]),e._v(" "),r("pre",{pre:!0},[r("code",{attrs:{"v-pre":""}},[e._v('@Data\n@NoArgsConstructor\n@AllArgsConstructor\n@JacksonXmlRootElement(localName = "User")\npublic class User {\n\n    @JacksonXmlProperty(localName = "name")\n    private String name;\n    @JacksonXmlProperty(localName = "age")\n    private Integer age;\n\n}\n')])]),e._v(" "),r("p",[e._v("其中："),r("code",{pre:!0},[e._v("@Data")]),e._v("、"),r("code",{pre:!0},[e._v("@NoArgsConstructor")]),e._v("、"),r("code",{pre:!0},[e._v("@AllArgsConstructor")]),e._v("是lombok简化代码的注解，主要用于生成get、set以及构造函数。"),r("code",{pre:!0},[e._v("@JacksonXmlRootElement")]),e._v("、"),r("code",{pre:!0},[e._v("@JacksonXmlProperty")]),e._v("注解是用来维护对象属性在xml中的对应关系。")]),e._v(" "),r("p",[e._v("上述配置的User对象，其可以映射的Xml样例如下（后续可以使用上述xml来请求接口）：")]),e._v(" "),r("pre",{pre:!0},[r("code",{attrs:{"v-pre":""}},[e._v("<User>\n\t<name>aaaa</name>\n\t<age>10</age>\n</User>\n")])]),e._v(" "),r("p",[r("strong",[e._v("第三步：创建接收xml请求的接口")])]),e._v(" "),r("p",[e._v("完成了要转换的对象之后，可以编写一个接口来接收xml并返回xml，比如：")]),e._v(" "),r("pre",{pre:!0},[r("code",{attrs:{"v-pre":""}},[e._v('@Controller\npublic class UserController {\n\n    @PostMapping(value = "/user", \n        consumes = MediaType.APPLICATION_XML_VALUE, \n        produces = MediaType.APPLICATION_XML_VALUE)\n    @ResponseBody\n    public User create(@RequestBody User user) {\n        user.setName("didispace.com : " + user.getName());\n        user.setAge(user.getAge() + 100);\n        return user;\n    }\n\n}\n')])]),e._v(" "),r("p",[e._v("最后，启动Spring Boot应用，通过POSTMAN等请求工具，尝试一下这个接口，可以看到请求Xml，并且返回了经过处理后的Xml内容。")]),e._v(" "),r("p",[r("img",{attrs:{src:n("gK0i"),alt:"pasted-121.png"}})]),e._v(" "),r("h2",[e._v("案例代码")]),e._v(" "),r("p",[e._v("可以通过下面两个仓库中查阅"),r("code",{pre:!0},[e._v("chapter3-1-8")]),e._v("目录：")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://github.com/dyc87112/SpringBoot-Learning/"}},[e._v("https://github.com/dyc87112/SpringBoot-Learning/")])])])])}]},ee={path:"/Web",cnName:"Web开发",component:L,name:"Web",children:[{path:"RESTfulAPI",component:n("C7Lr")(null,G,!1,null,null,null).exports,cnName:"构建RESTful API",title:"Spring Boot构建RESTful API与单元测试",date:"2018-11-07",name:"RESTfulAPI"},{path:"Thymeleaf",component:n("C7Lr")(null,Q,!1,null,null,null).exports,cnName:"Thymeleaf使用",title:"使用Thymeleaf模板引擎渲染web视图",date:"2018-11-08",name:"Thymeleaf"},{path:"Swagger2",component:n("C7Lr")(null,X,!1,null,null,null).exports,cnName:"Swagger2构建API文档",title:"Spring Boot中使用Swagger2构建强大的RESTful API文档",date:"2018-11-09",name:"Swagger2"},{path:"Abnormity",component:n("C7Lr")(null,Y,!1,null,null,null).exports,cnName:"统一异常处理",title:"Spring Boot中Web应用的统一异常处理",date:"2018-11-10",name:"Abnormity"},{path:"Java8Api",component:n("C7Lr")(null,K,!1,null,null,null).exports,title:"Spring Boot和Feign中使用Java 8时间日期API",date:"2018-11-11",cnName:"Java 8时间日期API",name:"Java8Api"},{path:"XMLResponse",component:n("C7Lr")(null,Z,!1,null,null,null).exports,title:"Spring Boot中如何扩展XML请求和响应的支持",date:"2018-11-12",cnName:"XML请求和响应的支持",name:"XMLResponse"}]},te={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("p",[e._v("我们在编写Spring Boot应用中经常会遇到这样的场景，比如：我需要定时地发送一些短信、邮件之类的操作，也可能会定时地检查和监控一些标志、参数等。")]),e._v(" "),n("h2",[e._v("创建定时任务")]),e._v(" "),n("p",[e._v("在Spring Boot中编写定时任务是非常简单的事，下面通过实例介绍如何在Spring Boot中创建定时任务，实现每过5秒输出一下当前时间。")]),e._v(" "),n("ul",[n("li",[e._v("在Spring Boot的主类中加入"),n("code",{pre:!0},[e._v("@EnableScheduling")]),e._v("注解，启用定时任务的配置")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("@SpringBootApplication\n@EnableScheduling\npublic class Application {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Application.class, args);\n\t}\n\n}\n")])]),e._v(" "),n("ul",[n("li",[e._v("创建定时任务实现类")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@Component\npublic class ScheduledTasks {\n\n    private static final SimpleDateFormat dateFormat = new SimpleDateFormat("HH:mm:ss");\n\n    @Scheduled(fixedRate = 5000)\n    public void reportCurrentTime() {\n        System.out.println("现在时间：" + dateFormat.format(new Date()));\n    }\n\n}\n')])]),e._v(" "),n("ul",[n("li",[e._v("运行程序，控制台中可以看到类似如下输出，定时任务开始正常运作了。")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("2016-05-15 10:40:04.073  INFO 1688 --- [           main] com.didispace.Application                : Started Application in 1.433 seconds (JVM running for 1.967)\n现在时间：10:40:09\n现在时间：10:40:14\n现在时间：10:40:19\n现在时间：10:40:24\n现在时间：10:40:29522\n现在时间：10:40:34\n")])]),e._v(" "),n("p",[e._v("关于上述的简单入门示例也可以参见官方的"),n("a",{attrs:{href:"http://spring.io/guides/gs/scheduling-tasks/"}},[e._v("Scheduling Tasks")])]),e._v(" "),n("h3",[e._v("@Scheduled详解")]),e._v(" "),n("p",[e._v("在上面的入门例子中，使用了"),n("code",{pre:!0},[e._v("@Scheduled(fixedRate = 5000)")]),e._v(" 注解来定义每过5秒执行的任务，对于"),n("code",{pre:!0},[e._v("@Scheduled")]),e._v("的使用可以总结如下几种方式：")]),e._v(" "),n("ul",[n("li",[n("code",{pre:!0},[e._v("@Scheduled(fixedRate = 5000)")]),e._v(" ：上一次开始执行时间点之后5秒再执行")]),e._v(" "),n("li",[n("code",{pre:!0},[e._v("@Scheduled(fixedDelay = 5000)")]),e._v(" ：上一次执行完毕时间点之后5秒再执行")]),e._v(" "),n("li",[n("code",{pre:!0},[e._v("@Scheduled(initialDelay=1000, fixedRate=5000)")]),e._v(" ：第一次延迟1秒后执行，之后按fixedRate的规则每5秒执行一次")]),e._v(" "),n("li",[n("code",{pre:!0},[e._v('@Scheduled(cron="*/5 * * * * *")')]),e._v(" ：通过cron表达式定义规则")])]),e._v(" "),n("p",[n("a",{attrs:{href:"%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8BChapter4-1-1"}},[e._v("完整示例Chapter4-1-1")])])])}]},ne={render:function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("p",[e._v("什么是“异步调用”？")]),e._v(" "),n("p",[e._v("“异步调用”对应的是“同步调用”，同步调用指程序按照定义顺序依次执行，每一行程序都必须等待上一行程序执行完成之后才能执行；异步调用指程序在顺序执行时，不等待异步调用的语句返回结果就执行后面的程序。")]),e._v(" "),n("h3",[e._v("同步调用")]),e._v(" "),n("p",[e._v("下面通过一个简单示例来直观的理解什么是同步调用：")]),e._v(" "),e._m(0),e._v(" "),e._m(1),e._v(" "),e._m(2),e._v(" "),e._m(3),e._v(" "),e._m(4),e._v(" "),e._m(5),e._v(" "),e._m(6),e._v(" "),n("h3",[e._v("异步调用")]),e._v(" "),n("p",[e._v("上述的同步调用虽然顺利的执行完了三个任务，但是可以看到执行时间比较长，若这三个任务本身之间不存在依赖关系，可以并发执行的话，同步调用在执行效率方面就比较差，可以考虑通过异步调用的方式来并发执行。")]),e._v(" "),e._m(7),e._v(" "),e._m(8),e._v(" "),n("p",[e._v("为了让@Async注解能够生效，还需要在Spring Boot的主程序中配置@EnableAsync，如下所示：")]),e._v(" "),e._m(9),e._v(" "),n("p",[e._v("此时可以反复执行单元测试，您可能会遇到各种不同的结果，比如：")]),e._v(" "),e._m(10),e._v(" "),e._m(11),e._v(" "),e._m(12),e._v(" "),n("h3",[e._v("异步回调")]),e._v(" "),e._m(13),e._v(" "),e._m(14),e._v(" "),e._m(15),e._v(" "),n("p",[e._v("按照如上方式改造一下其他两个异步函数之后，下面我们改造一下测试用例，让测试在等待完成三个异步调用之后来做一些其他事情。")]),e._v(" "),e._m(16),e._v(" "),n("p",[e._v("看看我们做了哪些改变：")]),e._v(" "),n("ul",[n("li",[e._v("在测试用例一开始记录开始时间")]),e._v(" "),n("li",[e._v("在调用三个异步函数的时候，返回Future"),n("String",[e._v("类型的结果对象")])],1),e._v(" "),n("li",[e._v("在调用完三个异步函数之后，开启一个循环，根据返回的Future"),n("String",[e._v("对象来判断三个异步函数是否都结束了。若都结束，就结束循环；若没有都结束，就等1秒后再判断。")])],1),e._v(" "),n("li",[e._v("跳出循环之后，根据结束时间 - 开始时间，计算出三个任务并发执行的总耗时。")])]),e._v(" "),n("p",[e._v("执行一下上述的单元测试，可以看到如下结果：")]),e._v(" "),e._m(17),e._v(" "),n("p",[e._v("可以看到，通过异步调用，让任务一、二、三并发执行，有效的减少了程序的总运行时间。")]),e._v(" "),e._m(18)])},staticRenderFns:[function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("定义Task类，创建三个处理函数分别模拟三个执行任务的操作，操作消耗时间随机取（10秒内）")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[this._v('@Component\npublic class Task {\n\n    public static Random random =new Random();\n\n    public void doTaskOne() throws Exception {\n        System.out.println("开始做任务一");\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println("完成任务一，耗时：" + (end - start) + "毫秒");\n    }\n\n    public void doTaskTwo() throws Exception {\n        System.out.println("开始做任务二");\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println("完成任务二，耗时：" + (end - start) + "毫秒");\n    }\n\n    public void doTaskThree() throws Exception {\n        System.out.println("开始做任务三");\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println("完成任务三，耗时：" + (end - start) + "毫秒");\n    }\n}\n')])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("在单元测试用例中，注入Task对象，并在测试用例中执行doTaskOne、doTaskTwo、doTaskThree三个函数。")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[this._v("@RunWith(SpringJUnit4ClassRunner.class)\n@SpringApplicationConfiguration(classes = Application.class)\npublic class ApplicationTests {\n\n\t@Autowired\n\tprivate Task task;\n\n\t@Test\n\tpublic void test() throws Exception {\n\t\ttask.doTaskOne();\n\t\ttask.doTaskTwo();\n\t\ttask.doTaskThree();\n\t}\n\n}\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("执行单元测试，可以看到类似如下输出：")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[this._v("开始做任务一\n完成任务一，耗时：4256毫秒\n开始做任务二\n完成任务二，耗时：4957毫秒\n开始做任务三\n完成任务三，耗时：7173毫秒\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("任务一、任务二、任务三顺序的执行完了，换言之"),t("code",{pre:!0},[this._v("doTaskOne")]),this._v("、"),t("code",{pre:!0},[this._v("doTaskTwo")]),this._v("、"),t("code",{pre:!0},[this._v("doTaskThree")]),this._v("三个函数顺序的执行完成。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("在Spring Boot中，我们只需要通过使用"),t("code",{pre:!0},[this._v("@Async")]),this._v("注解就能简单的将原来的同步函数变为异步函数，Task类改在为如下模式：")])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[this._v("@Component\npublic class Task {\n\n    @Async\n    public void doTaskOne() throws Exception {\n        // 同上内容，省略\n    }\n\n    @Async\n    public void doTaskTwo() throws Exception {\n        // 同上内容，省略\n    }\n\n    @Async\n    public void doTaskThree() throws Exception {\n        // 同上内容，省略\n    }\n\n}\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[this._v("@SpringBootApplication\n@EnableAsync\npublic class Application {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(Application.class, args);\n\t}\n\n}\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("没有任何任务相关的输出")]),this._v(" "),t("li",[this._v("有部分任务相关的输出")]),this._v(" "),t("li",[this._v("乱序的任务相关的输出")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("原因是目前"),t("code",{pre:!0},[this._v("doTaskOne")]),this._v("、"),t("code",{pre:!0},[this._v("doTaskTwo")]),this._v("、"),t("code",{pre:!0},[this._v("doTaskThree")]),this._v("三个函数的时候已经是异步执行了。主程序在异步调用之后，主程序并不会理会这三个函数是否执行完成了，由于没有其他需要执行的内容，所以程序就自动结束了，导致了不完整或是没有输出任务相关内容的情况。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("__注： "),t("strong",[this._v("at__Async所修饰的函数不要定义为static类型，这样异步调用不会生效")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("为了让"),t("code",{pre:!0},[this._v("doTaskOne")]),this._v("、"),t("code",{pre:!0},[this._v("doTaskTwo")]),this._v("、"),t("code",{pre:!0},[this._v("doTaskThree")]),this._v("能正常结束，假设我们需要统计一下三个任务并发执行共耗时多少，这就需要等到上述三个函数都完成调动之后记录时间，并计算结果。")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("那么我们如何判断上述三个异步调用是否已经执行完成呢？我们需要使用"),t("code",{pre:!0},[this._v("Future<T>")]),this._v("来返回异步调用的结果，就像如下方式改造"),t("code",{pre:!0},[this._v("doTaskOne")]),this._v("函数：")])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[this._v('@Async\npublic Future<String> doTaskOne() throws Exception {\n    System.out.println("开始做任务一");\n    long start = System.currentTimeMillis();\n    Thread.sleep(random.nextInt(10000));\n    long end = System.currentTimeMillis();\n    System.out.println("完成任务一，耗时：" + (end - start) + "毫秒");\n    return new AsyncResult<>("任务一完成");\n}\n')])])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[this._v('@Test\npublic void test() throws Exception {\n\n\tlong start = System.currentTimeMillis();\n\n\tFuture<String> task1 = task.doTaskOne();\n\tFuture<String> task2 = task.doTaskTwo();\n\tFuture<String> task3 = task.doTaskThree();\n\n\twhile(true) {\n\t\tif(task1.isDone() && task2.isDone() && task3.isDone()) {\n\t\t\t// 三个任务都调用完成，退出循环等待\n\t\t\tbreak;\n\t\t}\n\t\tThread.sleep(1000);\n\t}\n\n\tlong end = System.currentTimeMillis();\n\n\tSystem.out.println("任务全部完成，总耗时：" + (end - start) + "毫秒");\n}\n')])])},function(){var e=this.$createElement,t=this._self._c||e;return t("pre",{pre:!0},[t("code",{attrs:{"v-pre":""}},[this._v("开始做任务一\n开始做任务二\n开始做任务三\n完成任务三，耗时：37毫秒\n完成任务二，耗时：3661毫秒\n完成任务一，耗时：7149毫秒\n任务全部完成，总耗时：8025毫秒\n")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("a",{attrs:{href:"%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8BChapter4-1-2"}},[this._v("完整示例Chapter4-1-2")])])}]},re={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("blockquote",[n("p",[e._v("在之前的Spring Boot基础教程系列中，已经通过"),n("a",{attrs:{href:"#/async/asyncCall"}},[e._v("《Spring Boot中使用@Async实现异步调用》")]),e._v("一文介绍过如何使用"),n("code",{pre:!0},[e._v("@Async")]),e._v("注解来实现异步调用了。但是，对于这些异步执行的控制是我们保障自身应用健康的基本技能。本文我们就来学习一下，如果通过自定义线程池的方式来控制异步调用的并发。")])]),e._v(" "),n("p",[e._v("本文中的例子我们可以在之前的例子基础上修改，也可以创建一个全新的Spring Boot项目来尝试。")]),e._v(" "),n("h2",[e._v("定义线程池")]),e._v(" "),n("p",[e._v("第一步，创建"),n("code",{pre:!0},[e._v("TaskPoolConfig")]),e._v("类中定义一个线程池，比如：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@EnableAsync\n@Configuration\npublic class TaskPoolConfig {\n\n    @Bean("taskExecutor")\n    public Executor taskExecutor(){\n        ThreadPoolTaskExecutor executor=new ThreadPoolTaskExecutor();\n        executor.setCorePoolSize(10);\n        executor.setMaxPoolSize(20);\n        executor.setQueueCapacity(200);\n        executor.setKeepAliveSeconds(60);\n        executor.setThreadNamePrefix("taskExecutor-");\n        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());\n        return executor;\n    }\n}\n')])]),e._v(" "),n("p",[e._v("上面我们通过使用"),n("code",{pre:!0},[e._v("ThreadPoolTaskExecutor")]),e._v("创建了一个线程池，同时设置了以下这些参数：")]),e._v(" "),n("ul",[n("li",[e._v("核心线程数10：线程池创建时候初始化的线程数")]),e._v(" "),n("li",[e._v("最大线程数20：线程池最大的线程数，只有在缓冲队列满了之后才会申请超过核心线程数的线程")]),e._v(" "),n("li",[e._v("缓冲队列200：用来缓冲执行任务的队列")]),e._v(" "),n("li",[e._v("允许线程的空闲时间60秒：当超过了核心线程出之外的线程在空闲时间到达之后会被销毁")]),e._v(" "),n("li",[e._v("线程池名的前缀：设置好了之后可以方便我们定位处理任务所在的线程池")]),e._v(" "),n("li",[e._v("线程池对拒绝任务的处理策略：这里采用了CallerRunsPolicy策略，当线程池没有处理能力的时候，该策略会直接在 execute 方法的调用线程中运行被拒绝的任务；如果执行程序已关闭，则会丢弃该任务")])]),e._v(" "),n("h2",[e._v("使用线程池")]),e._v(" "),n("p",[e._v("在定义了线程池之后，我们如何让异步调用的执行任务使用这个线程池中的资源来运行呢？方法非常简单，我们只需要在"),n("code",{pre:!0},[e._v("@Async")]),e._v("注解中指定线程池名即可，比如：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@Slf4j\n@Component\npublic class Task {\n\n    public static Random random = new Random();\n\n    @Async("taskExecutor")\n    public void doTaskOne() throws Exception {\n        log.info("开始做任务一");\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        log.info("完成任务一，耗时：" + (end - start) + "毫秒");\n    }\n\n    @Async("taskExecutor")\n    public void doTaskTwo() throws Exception {\n        log.info("开始做任务二");\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        log.info("完成任务二，耗时：" + (end - start) + "毫秒");\n    }\n\n    @Async("taskExecutor")\n    public void doTaskThree() throws Exception {\n        log.info("开始做任务三");\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        log.info("完成任务三，耗时：" + (end - start) + "毫秒");\n    }\n}\n')])]),e._v(" "),n("h2",[e._v("单元测试")]),e._v(" "),n("p",[e._v("最后，我们来写个单元测试来验证一下")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("@RunWith(SpringJUnit4ClassRunner.class)\n@SpringBootTest\npublic class ApplicationTests {\n\n    @Autowired\n    private Task task;\n\n    @Test\n    public void test() throws Exception {\n\n        task.doTaskOne();\n        task.doTaskTwo();\n        task.doTaskThree();\n\n        Thread.currentThread().join();\n    }\n}\n")])]),e._v(" "),n("p",[e._v("执行上面的单元测试，我们可以在控制台中看到所有输出的线程名前都是之前我们定义的线程池前缀名开始的，说明我们使用线程池来执行异步任务的试验成功了！")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("2018-03-27 22:01:15.620  INFO 73703 --- [ taskExecutor-1] com.didispace.async.Task                 : 开始做任务一\n2018-03-27 22:01:15.620  INFO 73703 --- [ taskExecutor-2] com.didispace.async.Task                 : 开始做任务二\n2018-03-27 22:01:15.620  INFO 73703 --- [ taskExecutor-3] com.didispace.async.Task                 : 开始做任务三\n2018-03-27 22:01:18.165  INFO 73703 --- [ taskExecutor-2] com.didispace.async.Task                 : 完成任务二，耗时：2545毫秒\n2018-03-27 22:01:22.149  INFO 73703 --- [ taskExecutor-3] com.didispace.async.Task                 : 完成任务三，耗时：6529毫秒\n2018-03-27 22:01:23.912  INFO 73703 --- [ taskExecutor-1] com.didispace.async.Task                 : 完成任务一，耗时：8292毫秒\n")])]),e._v(" "),n("p",[n("a",{attrs:{href:"lesson5-3"}},[e._v("完整示例:lesson5-3")])])])}]},ae={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("blockquote",[n("p",[e._v("上周发了一篇关于Spring Boot中使用"),n("code",{pre:!0},[e._v("@Async")]),e._v("来实现异步任务和线程池控制的文章："),n("a",{attrs:{href:"#/async/taskExecutor"}},[e._v("《Spring Boot使用@Async实现异步调用：自定义线程池》")]),e._v("。由于最近身边也发现了不少异步任务没有正确处理而导致的不少问题，所以在本文就接前面内容，继续说说线程池的优雅关闭，主要针对"),n("code",{pre:!0},[e._v("ThreadPoolTaskScheduler")]),e._v("线程池。")])]),e._v(" "),n("h2",[e._v("问题现象")]),e._v(" "),n("p",[e._v("在上篇文章的例子[lesson5-3]中，我们定义了一个线程池，然后利用"),n("code",{pre:!0},[e._v("@Async")]),e._v("注解写了3个任务，并指定了这些任务执行使用的线程池。在上文的单元测试中，我们没有具体说说shutdown相关的问题，下面我们就来模拟一个问题现场出来。")]),e._v(" "),n("p",[e._v("第一步：如前文一样，我们定义一个"),n("code",{pre:!0},[e._v("ThreadPoolTaskScheduler")]),e._v("线程池：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@EnableAsync\n@Configuration\npublic class TaskPoolConfig {\n\n    @Bean("taskExecutor")\n    public Executor taskExecutor() {\n        ThreadPoolTaskScheduler executor = new ThreadPoolTaskScheduler();\n        executor.setPoolSize(20);\n        executor.setThreadNamePrefix("taskExecutor-");\n\n        executor.setWaitForTasksToCompleteOnShutdown(true);\n        executor.setAwaitTerminationSeconds(60);\n        return executor;\n    }\n}\n')])]),e._v(" "),n("p",[e._v("第二步：改造之前的异步任务，让它依赖一个外部资源，比如：Redis")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@Slf4j\n@Component\npublic class Task {\n\n    @Autowired\n    private StringRedisTemplate stringRedisTemplate;\n\n    @Async("taskExecutor")\n    public void doTaskOne() throws Exception {\n        log.info("开始做任务一");\n        long start = System.currentTimeMillis();\n        log.info(stringRedisTemplate.randomKey());\n        long end = System.currentTimeMillis();\n        log.info("完成任务一，耗时：" + (end - start) + "毫秒");\n    }\n\n    @Async("taskExecutor")\n    public void doTaskTwo() throws Exception {\n        log.info("开始做任务二");\n        long start = System.currentTimeMillis();\n        log.info(stringRedisTemplate.randomKey());\n        long end = System.currentTimeMillis();\n        log.info("完成任务二，耗时：" + (end - start) + "毫秒");\n    }\n\n    @Async("taskExecutor")\n    public void doTaskThree() throws Exception {\n        log.info("开始做任务三");\n        long start = System.currentTimeMillis();\n        log.info(stringRedisTemplate.randomKey());\n        long end = System.currentTimeMillis();\n        log.info("完成任务三，耗时：" + (end - start) + "毫秒");\n    }\n}\n')])]),e._v(" "),n("p",[n("strong",[e._v("注意：这里省略了pom.xml中引入依赖和配置redis的步骤")])]),e._v(" "),n("p",[e._v("第三步：修改单元测试，模拟高并发情况下ShutDown的情况：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("@RunWith(SpringJUnit4ClassRunner.class)\n@SpringBootTest\npublic class ApplicationTests {\n\n    @Autowired\n    private Task task;\n\n    @Test\n    @SneakyThrows\n    public void test() {\n\n        for (int i = 0; i < 10000; i++) {\n            task.doTaskOne();\n            task.doTaskTwo();\n            task.doTaskThree();\n\n            if (i == 9999) {\n                System.exit(0);\n            }\n        }\n    }\n}\n")])]),e._v(" "),n("p",[e._v("说明：通过for循环往上面定义的线程池中提交任务，由于是异步执行，在执行过程中，利用"),n("code",{pre:!0},[e._v("System.exit(0)")]),e._v("来关闭程序，此时由于有任务在执行，就可以观察这些异步任务的销毁与Spring容器中其他资源的顺序是否安全。")]),e._v(" "),n("p",[e._v("第四步：运行上面的单元测试，我们将碰到下面的异常内容。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("org.springframework.data.redis.RedisConnectionFailureException: Cannot get Jedis connection; nested exception is redis.clients.jedis.exceptions.JedisConnectionException: Could not get a resource from the pool\n\tat org.springframework.data.redis.connection.jedis.JedisConnectionFactory.fetchJedisConnector(JedisConnectionFactory.java:204) ~[spring-data-redis-1.8.10.RELEASE.jar:na]\n\tat org.springframework.data.redis.connection.jedis.JedisConnectionFactory.getConnection(JedisConnectionFactory.java:348) ~[spring-data-redis-1.8.10.RELEASE.jar:na]\n\tat org.springframework.data.redis.core.RedisConnectionUtils.doGetConnection(RedisConnectionUtils.java:129) ~[spring-data-redis-1.8.10.RELEASE.jar:na]\n\tat org.springframework.data.redis.core.RedisConnectionUtils.getConnection(RedisConnectionUtils.java:92) ~[spring-data-redis-1.8.10.RELEASE.jar:na]\n\tat org.springframework.data.redis.core.RedisConnectionUtils.getConnection(RedisConnectionUtils.java:79) ~[spring-data-redis-1.8.10.RELEASE.jar:na]\n\tat org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:194) ~[spring-data-redis-1.8.10.RELEASE.jar:na]\n\tat org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:169) ~[spring-data-redis-1.8.10.RELEASE.jar:na]\n\tat org.springframework.data.redis.core.RedisTemplate.randomKey(RedisTemplate.java:781) ~[spring-data-redis-1.8.10.RELEASE.jar:na]\n\tat com.didispace.async.Task.doTaskOne(Task.java:26) ~[classes/:na]\n\tat com.didispace.async.Task$$FastClassBySpringCGLIB$$ca3ff9d6.invoke(<generated>) ~[classes/:na]\n\tat org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204) ~[spring-core-4.3.14.RELEASE.jar:4.3.14.RELEASE]\n\tat org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:738) ~[spring-aop-4.3.14.RELEASE.jar:4.3.14.RELEASE]\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157) ~[spring-aop-4.3.14.RELEASE.jar:4.3.14.RELEASE]\n\tat org.springframework.aop.interceptor.AsyncExecutionInterceptor$1.call(AsyncExecutionInterceptor.java:115) ~[spring-aop-4.3.14.RELEASE.jar:4.3.14.RELEASE]\n\tat java.util.concurrent.FutureTask.run(FutureTask.java:266) [na:1.8.0_151]\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180) [na:1.8.0_151]\n\tat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293) [na:1.8.0_151]\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_151]\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_151]\n\tat java.lang.Thread.run(Thread.java:748) [na:1.8.0_151]\nCaused by: redis.clients.jedis.exceptions.JedisConnectionException: Could not get a resource from the pool\n\tat redis.clients.util.Pool.getResource(Pool.java:53) ~[jedis-2.9.0.jar:na]\n\tat redis.clients.jedis.JedisPool.getResource(JedisPool.java:226) ~[jedis-2.9.0.jar:na]\n\tat redis.clients.jedis.JedisPool.getResource(JedisPool.java:16) ~[jedis-2.9.0.jar:na]\n\tat org.springframework.data.redis.connection.jedis.JedisConnectionFactory.fetchJedisConnector(JedisConnectionFactory.java:194) ~[spring-data-redis-1.8.10.RELEASE.jar:na]\n\t... 19 common frames omitted\nCaused by: java.lang.InterruptedException: null\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.reportInterruptAfterWait(AbstractQueuedSynchronizer.java:2014) ~[na:1.8.0_151]\n\tat java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2088) ~[na:1.8.0_151]\n\tat org.apache.commons.pool2.impl.LinkedBlockingDeque.pollFirst(LinkedBlockingDeque.java:635) ~[commons-pool2-2.4.3.jar:2.4.3]\n\tat org.apache.commons.pool2.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:442) ~[commons-pool2-2.4.3.jar:2.4.3]\n\tat org.apache.commons.pool2.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:361) ~[commons-pool2-2.4.3.jar:2.4.3]\n\tat redis.clients.util.Pool.getResource(Pool.java:49) ~[jedis-2.9.0.jar:na]\n\t... 22 common frames omitted\n")])]),e._v(" "),n("h2",[e._v("如何解决")]),e._v(" "),n("h3",[e._v("原因分析")]),e._v(" "),n("p",[e._v("从异常信息"),n("code",{pre:!0},[e._v("JedisConnectionException: Could not get a resource from the pool")]),e._v("来看，我们很容易的可以想到，在应用关闭的时候异步任务还在执行，由于Redis连接池先销毁了，导致异步任务中要访问Redis的操作就报了上面的错。所以，我们得出结论，上面的实现方式在应用关闭的时候是不优雅的，那么我们要怎么做呢？")]),e._v(" "),n("h3",[e._v("解决方法")]),e._v(" "),n("p",[e._v("要解决上面的问题很简单，Spring的"),n("code",{pre:!0},[e._v("ThreadPoolTaskScheduler")]),e._v("为我们提供了相关的配置，只需要加入如下设置即可：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@Bean("taskExecutor")\npublic Executor taskExecutor() {\n    ThreadPoolTaskScheduler executor = new ThreadPoolTaskScheduler();\n    executor.setPoolSize(20);\n    executor.setThreadNamePrefix("taskExecutor-");\n    executor.setWaitForTasksToCompleteOnShutdown(true);\n    executor.setAwaitTerminationSeconds(60);\n    return executor;\n}\n')])]),e._v(" "),n("p",[e._v("说明："),n("code",{pre:!0},[e._v("setWaitForTasksToCompleteOnShutdown（true）")]),e._v("该方法就是这里的关键，用来设置线程池关闭的时候等待所有任务都完成再继续销毁其他的Bean，这样这些异步任务的销毁就会先于Redis线程池的销毁。同时，这里还设置了"),n("code",{pre:!0},[e._v("setAwaitTerminationSeconds(60)")]),e._v("，该方法用来设置线程池中任务的等待时间，如果超过这个时候还没有销毁就强制销毁，以确保应用最后能够被关闭，而不是阻塞住。")]),e._v(" "),n("p",[n("a",{attrs:{href:"lesson5-4"}},[e._v("完整示例：lesson5-4")])])])}]},oe={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("p",[e._v("之前连续写了几篇关于使用"),n("code",{pre:!0},[e._v("@Async")]),e._v("实现异步调用的内容，也得到不少童鞋的反馈，其中问题比较多的就是关于返回"),n("code",{pre:!0},[e._v("Future")]),e._v("的使用方法以及对异步执行的超时控制，所以这篇就来一起讲讲这两个问题的处理。")]),e._v(" "),n("h2",[e._v("定义异步任务")]),e._v(" "),n("p",[e._v("首先，我们先使用"),n("code",{pre:!0},[e._v("@Async")]),e._v("注解来定义一个异步任务，这个方法返回"),n("code",{pre:!0},[e._v("Future")]),e._v("类型，具体如下：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v('@Slf4j\n@Component\npublic class Task {\n\n    public static Random random = new Random();\n\n    @Async("taskExecutor")\n    public Future<String> run() throws Exception {\n        long sleep = random.nextInt(10000);\n        log.info("开始任务，需耗时：" + sleep + "毫秒");\n        Thread.sleep(sleep);\n        log.info("完成任务");\n        return new AsyncResult<>("test");\n    }\n\n}\n')])]),e._v(" "),n("h3",[e._v("Tips：什么是"),n("code",{pre:!0},[e._v("Future")]),e._v("类型？")]),e._v(" "),n("p",[n("code",{pre:!0},[e._v("Future")]),e._v("是对于具体的"),n("code",{pre:!0},[e._v("Runnable")]),e._v("或者"),n("code",{pre:!0},[e._v("Callable")]),e._v("任务的执行结果进行取消、查询是否完成、获取结果的接口。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。")]),e._v(" "),n("p",[e._v("它的接口定义如下：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("public interface Future<V> {\n    boolean cancel(boolean mayInterruptIfRunning);\n    boolean isCancelled();\n    boolean isDone();\n    V get() throws InterruptedException, ExecutionException;\n    V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException;\n}\n")])]),e._v(" "),n("p",[e._v("它声明这样的五个方法：")]),e._v(" "),n("ul",[n("li",[e._v("cancel方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。")]),e._v(" "),n("li",[e._v("isCancelled方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。")]),e._v(" "),n("li",[e._v("isDone方法表示任务是否已经完成，若任务完成，则返回true；")]),e._v(" "),n("li",[e._v("get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；")]),e._v(" "),n("li",[e._v("get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。")])]),e._v(" "),n("p",[e._v("也就是说Future提供了三种功能：")]),e._v(" "),n("ol",[n("li",[e._v("判断任务是否完成；")]),e._v(" "),n("li",[e._v("能够中断任务；")]),e._v(" "),n("li",[e._v("能够获取任务执行结果。")])]),e._v(" "),n("h2",[e._v("测试执行与定义超时")]),e._v(" "),n("p",[e._v("在完成了返回"),n("code",{pre:!0},[e._v("Future")]),e._v("的异步任务定义之后，我们来尝试实现一个单元测试来使用这个Future完成任务的执行，比如：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("@Slf4j\n@RunWith(SpringJUnit4ClassRunner.class)\n@SpringBootTest\npublic class ApplicationTests {\n\n    @Autowired\n    private Task task;\n\n    @Test\n    public void test() throws Exception {\n        Future<String> futureResult = task.run();\n        String result = futureResult.get(5, TimeUnit.SECONDS);\n        log.info(result);\n    }\n}\n")])]),e._v(" "),n("p",[e._v("上面的代码中，我们在get方法中还定义了该线程执行的超时时间，通过执行这个测试我们可以观察到执行时间超过5秒的时候，这里会抛出超时异常，该执行线程就能够因执行超时而释放回线程池，不至于一直阻塞而占用资源。")]),e._v(" "),n("p",[n("a",{attrs:{href:"lesson5-5"}},[e._v("完整示例：lesson5-5")])])])}]},ie={path:"/async",cnName:"定时任务与异步",component:L,name:"async",children:[{path:"scheduled",component:n("C7Lr")(null,te,!1,null,null,null).exports,cnName:"创建定时任务",title:"Spring Boot中使用@Scheduled创建定时任务",date:"2018-11-16",name:"scheduled"},{path:"asyncCall",component:n("C7Lr")(null,ne,!1,null,null,null).exports,cnName:"异步调用实现",title:"Spring Boot中使用@Async实现异步调用",date:"2018-11-17",name:"asyncCall"},{path:"taskExecutor",component:n("C7Lr")(null,re,!1,null,null,null).exports,cnName:"自定义线程池",title:"Spring Boot使用@Async实现异步调用：自定义线程池",date:"2018-11-18",name:"taskExecutor"},{path:"taskClose",component:n("C7Lr")(null,ae,!1,null,null,null).exports,cnName:"资源优雅关闭",title:"Spring Boot使用@Async实现异步调用：ThreadPoolTaskScheduler线程池的优雅关闭",date:"2018-11-19",name:"taskClose"},{path:"future",component:n("C7Lr")(null,oe,!1,null,null,null).exports,cnName:"超时定义",title:"Spring Boot使用@Async实现异步调用：使用Future以及定义超时",date:"2018-11-20",name:"future"}]},se={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("p",[e._v("Spring Boot在所有内部日志中使用"),n("a",{attrs:{href:"http://commons.apache.org/proper/commons-logging/"}},[e._v("Commons Logging")]),e._v("，但是默认配置也提供了对常用日志的支持，如："),n("a",{attrs:{href:"http://docs.oracle.com/javase/7/docs/api/java/util/logging/package-summary.html"}},[e._v("Java Util Logging")]),e._v("，"),n("a",{attrs:{href:"http://logging.apache.org/log4j/"}},[e._v("Log4J")]),e._v(", "),n("a",{attrs:{href:"http://logging.apache.org/log4j/"}},[e._v("Log4J2")]),e._v("和"),n("a",{attrs:{href:"http://logback.qos.ch/"}},[e._v("Logback")]),e._v("。每种Logger都可以通过配置使用控制台或者文件输出日志内容。")]),e._v(" "),n("h2",[e._v("格式化日志")]),e._v(" "),n("p",[e._v("默认的日志输出如下：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("2018-11-21 08:23:50.120  INFO 37397 --- [           main] org.hibernate.Version                    : HHH000412: Hibernate Core {4.3.11.Final}\n")])]),e._v(" "),n("p",[e._v("输出内容元素具体如下：")]),e._v(" "),n("ul",[n("li",[e._v("时间日期 — 精确到毫秒")]),e._v(" "),n("li",[e._v("日志级别 — ERROR, WARN, INFO, DEBUG or TRACE")]),e._v(" "),n("li",[e._v("进程ID")]),e._v(" "),n("li",[e._v("分隔符 — --- 标识实际日志的开始")]),e._v(" "),n("li",[e._v("线程名 — 方括号括起来（可能会截断控制台输出）")]),e._v(" "),n("li",[e._v("Logger名 — 通常使用源代码的类名")]),e._v(" "),n("li",[e._v("日志内容")])]),e._v(" "),n("h2",[e._v("控制台输出")]),e._v(" "),n("p",[e._v("在Spring Boot中默认配置了"),n("code",{pre:!0},[e._v("ERROR")]),e._v("、"),n("code",{pre:!0},[e._v("WARN")]),e._v("和"),n("code",{pre:!0},[e._v("INFO")]),e._v("级别的日志输出到控制台。")]),e._v(" "),n("p",[e._v("我们可以通过两种方式切换至"),n("code",{pre:!0},[e._v("DEBUG")]),e._v("级别：")]),e._v(" "),n("ul",[n("li",[e._v("在运行命令后加入"),n("code",{pre:!0},[e._v("--debug")]),e._v("标志，如："),n("code",{pre:!0},[e._v("$ java -jar myapp.jar --debug")])]),e._v(" "),n("li",[e._v("在"),n("code",{pre:!0},[e._v("application.properties")]),e._v("中配置"),n("code",{pre:!0},[e._v("debug=true")]),e._v("，该属性置为true的时候，核心Logger（包含嵌入式容器、hibernate、spring）会输出更多内容，但是你自己应用的日志并不会输出为DEBUG级别。")])]),e._v(" "),n("p",[n("strong",[e._v("多彩输出")])]),e._v(" "),n("p",[e._v("如果你的终端支持ANSI，设置彩色输出会让日志更具可读性。通过在"),n("code",{pre:!0},[e._v("application.properties")]),e._v("中设置"),n("code",{pre:!0},[e._v("spring.output.ansi.enabled")]),e._v("参数来支持。")]),e._v(" "),n("ul",[n("li",[e._v("NEVER：禁用ANSI-colored输出（默认项）")]),e._v(" "),n("li",[e._v("DETECT：会检查终端是否支持ANSI，是的话就采用彩色输出（推荐项）")]),e._v(" "),n("li",[e._v("ALWAYS：总是使用ANSI-colored格式输出，若终端不支持的时候，会有很多干扰信息，不推荐使用")])]),e._v(" "),n("h2",[e._v("文件输出")]),e._v(" "),n("p",[e._v("Spring Boot默认配置只会输出到控制台，并不会记录到文件中，但是我们通常生产环境使用时都需要以文件方式记录。")]),e._v(" "),n("p",[e._v("若要增加文件输出，需要在"),n("code",{pre:!0},[e._v("application.properties")]),e._v("中配置"),n("code",{pre:!0},[e._v("logging.file")]),e._v("或"),n("code",{pre:!0},[e._v("logging.path")]),e._v("属性。")]),e._v(" "),n("ul",[n("li",[e._v("logging.file，设置文件，可以是绝对路径，也可以是相对路径。如："),n("code",{pre:!0},[e._v("logging.file=my.log")])]),e._v(" "),n("li",[e._v("logging.path，设置目录，会在该目录下创建spring.log文件，并写入日志内容，如："),n("code",{pre:!0},[e._v("logging.path=/var/log")])])]),e._v(" "),n("p",[n("strong",[e._v("日志文件会在10Mb大小的时候被截断，产生新的日志文件，默认级别为：ERROR、WARN、INFO")])]),e._v(" "),n("h2",[e._v("级别控制")]),e._v(" "),n("p",[e._v("在Spring Boot中只需要在"),n("code",{pre:!0},[e._v("application.properties")]),e._v("中进行配置完成日志记录的级别控制。")]),e._v(" "),n("p",[e._v("配置格式："),n("code",{pre:!0},[e._v("logging.level.*=LEVEL")])]),e._v(" "),n("ul",[n("li",[n("code",{pre:!0},[e._v("logging.level")]),e._v("：日志级别控制前缀，*为包名或Logger名")]),e._v(" "),n("li",[n("code",{pre:!0},[e._v("LEVEL")]),e._v("：选项TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF")])]),e._v(" "),n("p",[e._v("举例：")]),e._v(" "),n("ul",[n("li",[n("code",{pre:!0},[e._v("logging.level.com.didispace=DEBUG")]),e._v("："),n("code",{pre:!0},[e._v("com.didispace")]),e._v("包下所有class以DEBUG级别输出")]),e._v(" "),n("li",[n("code",{pre:!0},[e._v("logging.level.root=WARN")]),e._v("：root日志以WARN级别输出")])]),e._v(" "),n("h2",[e._v("自定义日志配置")]),e._v(" "),n("p",[e._v("由于日志服务一般都在ApplicationContext创建前就初始化了，它并不是必须通过Spring的配置文件控制。因此通过系统属性和传统的Spring Boot外部配置文件依然可以很好的支持日志控制和管理。")]),e._v(" "),n("p",[e._v("根据不同的日志系统，你可以按如下规则组织配置文件名，就能被正确加载：")]),e._v(" "),n("ul",[n("li",[e._v("Logback："),n("code",{pre:!0},[e._v("logback-spring.xml")]),e._v(", "),n("code",{pre:!0},[e._v("logback-spring.groovy")]),e._v(", "),n("code",{pre:!0},[e._v("logback.xml")]),e._v(", "),n("code",{pre:!0},[e._v("logback.groovy")])]),e._v(" "),n("li",[e._v("Log4j："),n("code",{pre:!0},[e._v("log4j-spring.properties")]),e._v(", "),n("code",{pre:!0},[e._v("log4j-spring.xml")]),e._v(", "),n("code",{pre:!0},[e._v("log4j.properties")]),e._v(", "),n("code",{pre:!0},[e._v("log4j.xml")])]),e._v(" "),n("li",[e._v("Log4j2："),n("code",{pre:!0},[e._v("log4j2-spring.xml")]),e._v(", "),n("code",{pre:!0},[e._v("log4j2.xml")])]),e._v(" "),n("li",[e._v("JDK (Java Util Logging)："),n("code",{pre:!0},[e._v("logging.properties")])])]),e._v(" "),n("p",[e._v("Spring Boot官方推荐优先使用带有"),n("code",{pre:!0},[e._v("-spring")]),e._v("的文件名作为你的日志配置（如使用"),n("code",{pre:!0},[e._v("logback-spring.xml")]),e._v("，而不是"),n("code",{pre:!0},[e._v("logback.xml")]),e._v("）")]),e._v(" "),n("h2",[e._v("自定义输出格式")]),e._v(" "),n("p",[e._v("在Spring Boot中可以通过在"),n("code",{pre:!0},[e._v("application.properties")]),e._v("配置如下参数控制输出格式：")]),e._v(" "),n("p",[e._v("logging.pattern.console：定义输出到控制台的样式（不支持JDK Logger）\nlogging.pattern.file：定义输出到文件的样式（不支持JDK Logger）")])])}]},pe={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("section",[n("p",[e._v("之前在"),n("a",{attrs:{href:"#/log/defaultLog"}},[e._v("Spring Boot日志管理")]),e._v(" 一文中主要介绍了Spring Boot中默认日志工具（logback）的基本配置内容。对于很多习惯使用log4j的开发者，Spring Boot依然可以很好的支持，只是需要做一些小小的配置功能。")]),e._v(" "),n("h2",[e._v("引入log4j依赖")]),e._v(" "),n("p",[e._v("在创建Spring Boot工程时，我们引入了"),n("code",{pre:!0},[e._v("spring-boot-starter")]),e._v("，其中包含了"),n("code",{pre:!0},[e._v("spring-boot-starter-logging")]),e._v("，该依赖内容就是Spring Boot默认的日志框架Logback，所以我们在引入log4j之前，需要先排除该包的依赖，再引入log4j的依赖，就像下面这样：")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter</artifactId>\n    <exclusions>\n        <exclusion> \n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-logging</artifactId>\n        </exclusion>\n    </exclusions>\n</dependency>\n\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-log4j2</artifactId>\n</dependency>\n")])]),e._v(" "),n("h2",[e._v("配置log4j.properties")]),e._v(" "),n("p",[e._v("在引入了log4j依赖之后，只需要在"),n("code",{pre:!0},[e._v("src/main/resources")]),e._v("目录下加入log4j.properties配置文件，就可以开始对应用的日志进行配置使用。")]),e._v(" "),n("h3",[e._v("控制台输出")]),e._v(" "),n("p",[e._v("通过如下配置，设定root日志的输出级别为INFO，appender为控制台输出stdout")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("# LOG4J配置\nlog4j.rootCategory=INFO, stdout\n\n# 控制台输出\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss,SSS} %5p %c{1}:%L - %m%n\n")])]),e._v(" "),n("h3",[e._v("输出到文件")]),e._v(" "),n("p",[e._v("在开发环境，我们只是输出到控制台没有问题，但是到了生产或测试环境，或许持久化日志内容，方便追溯问题原因。可以通过添加如下的appender内容，按天输出到不同的文件中去，同时还需要为"),n("code",{pre:!0},[e._v("log4j.rootCategory")]),e._v("添加名为file的appender，这样root日志就可以输出到"),n("code",{pre:!0},[e._v("logs/all.log")]),e._v("文件中了。")]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("#\nlog4j.rootCategory=INFO, stdout, file\n\n# root日志输出\nlog4j.appender.file=org.apache.log4j.DailyRollingFileAppender\nlog4j.appender.file.file=logs/all.log\nlog4j.appender.file.DatePattern='.'yyyy-MM-dd\nlog4j.appender.file.layout=org.apache.log4j.PatternLayout\nlog4j.appender.file.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss,SSS} %5p %c{1}:%L - %m%n\n")])]),e._v(" "),n("h3",[e._v("分类输出")]),e._v(" "),n("p",[e._v("当我们日志量较多的时候，查找问题会非常困难，常用的手段就是对日志进行分类，比如：")]),e._v(" "),n("ul",[n("li",[e._v("可以按不同package进行输出。通过定义输出到"),n("code",{pre:!0},[e._v("logs/my.log")]),e._v("的appender，并对"),n("code",{pre:!0},[e._v("com.lesson6-1")]),e._v("包下的日志级别设定为DEBUG级别、appender设置为输出到"),n("code",{pre:!0},[e._v("logs/my.log")]),e._v("的名为"),n("code",{pre:!0},[e._v("lesson61")]),e._v("的appender。")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("# com.didispace包下的日志配置\nlog4j.category.com.lesson61=DEBUG, didifile\n\n# com.didispace下的日志输出\nlog4j.appender.lesson61=org.apache.log4j.DailyRollingFileAppender\nlog4j.appender.lesson61.file=logs/my.log\nlog4j.appender.lesson61.DatePattern='.'yyyy-MM-dd\nlog4j.appender.lesson61.layout=org.apache.log4j.PatternLayout\nlog4j.appender.lesson61.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss,SSS} %5p %c{1}:%L ---- %m%n\n")])]),e._v(" "),n("ul",[n("li",[e._v("可以对不同级别进行分类，比如对ERROR级别输出到特定的日志文件中，具体配置可以如下。")])]),e._v(" "),n("pre",{pre:!0},[n("code",{attrs:{"v-pre":""}},[e._v("log4j.logger.error=errorfile\n# error日志输出\nlog4j.appender.errorfile=org.apache.log4j.DailyRollingFileAppender\nlog4j.appender.errorfile.file=logs/error.log\nlog4j.appender.errorfile.DatePattern='.'yyyy-MM-dd\nlog4j.appender.errorfile.Threshold = ERROR\nlog4j.appender.errorfile.layout=org.apache.log4j.PatternLayout\nlog4j.appender.errorfile.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss,SSS} %5p %c{1}:%L - %m%n\n")])]),e._v(" "),n("p",[e._v("本文主要介绍如何在spring boot中引入log4j，以及一些基础用法，对于更多log4j的用法，还请参考"),n("a",{attrs:{href:"http://logging.apache.org/log4j/1.2/"}},[e._v("log4j官方网站")])]),e._v(" "),n("p",[n("a",{attrs:{href:"lesson6-1"}},[e._v("完整示列：lesson6-1")])])])}]},ce={path:"/log",cnName:"日志管理",component:L,name:"log",children:[{path:"defaultLog",component:n("C7Lr")(null,se,!1,null,null,null).exports,cnName:"默认日志配置",title:"Spring Boot日志管理",date:"2018-11-21",name:"defaultLog"},{path:"log4j",component:n("C7Lr")(null,pe,!1,null,null,null).exports,cnName:"log4j日志使用",title:"Spring boot中使用log4j记录日志",date:"2018-11-22",name:"log4j"}]};r.default.use(v.a);var le=new v.a({routes:[{path:"/",name:"HelloWorld",component:A,cnName:"起步"},k,ee,z,ie,ce]}),ve=n("waDh"),_e=n.n(ve);n("rnh/"),n("vXEn"),n("xKbP"),n("svpZ");r.default.config.productionTip=!1,r.default.use(_e.a),r.default.directive("highlight",function(e){e.querySelectorAll("pre code").forEach(function(e){s.a.highlightBlock(e)})}),new r.default({el:"#app",router:le,components:{App:l},template:"<App/>"})},YUAb:function(e,t){},Yqqd:function(e,t,n){e.exports=n.p+"static/img/swagger2_1.497fe35.png"},Zx4y:function(e,t,n){e.exports=n.p+"static/img/zfb.682c258.png"},eD7Y:function(e,t,n){e.exports=n.p+"static/img/idea.bc93d09.png"},fONQ:function(e,t){},gK0i:function(e,t,n){e.exports=n.p+"static/img/pasted-121.08ce5ca.png"},knyi:function(e,t,n){e.exports=n.p+"static/img/abnormity.9a51d59.png"},mE74:function(e,t,n){e.exports=n.p+"static/img/spring-download.bbcf1eb.png"},"rnh/":function(e,t){},svpZ:function(e,t){},uTyR:function(e,t){},v9vT:function(e,t,n){e.exports=n.p+"static/img/helloworld.a65c0b2.png"},vXEn:function(e,t){},xKbP:function(e,t){},yoQO:function(e,t,n){e.exports=n.p+"static/img/springbootrestfulapi-1.a5727be.png"}},["NHnr"]);
//# sourceMappingURL=app.28896fc550f2ea5bc135.js.map